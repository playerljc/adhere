{"version":3,"file":"size.js","sources":["size.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar BYTE_UNITS = ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\r\nvar BIBYTE_UNITS = ['B', 'kiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];\r\nvar BIT_UNITS = ['b', 'kbit', 'Mbit', 'Gbit', 'Tbit', 'Pbit', 'Ebit', 'Zbit', 'Ybit'];\r\nvar BIBIT_UNITS = ['b', 'kibit', 'Mibit', 'Gibit', 'Tibit', 'Pibit', 'Eibit', 'Zibit', 'Yibit'];\r\nvar toLocaleString = function (number, locale, options) {\r\n    var result = number;\r\n    if (typeof locale === 'string' || Array.isArray(locale)) {\r\n        result = number.toLocaleString(locale, options);\r\n    }\r\n    else if (locale === true || options !== undefined) {\r\n        result = number.toLocaleString(undefined, options);\r\n    }\r\n    return result;\r\n};\r\nexport default {\r\n    /**\r\n     * prettyBytes\r\n     * @description Formats the given number using `Number#toLocaleString`.\r\n     * - If locale is a string, the value is expected to be a locale-key (for example: `de`).\r\n     * - If locale is true, the system default locale is used for translation.\r\n     * - If no value for locale is specified, the number is returned unmodified.\r\n     * @param {number} number - The number to format.\r\n     * @param {PrettyBytesOptions} options\r\n     */\r\n    prettyBytes: function (number, options) {\r\n        if (!Number.isFinite(number)) {\r\n            throw new TypeError(\"Expected a finite number, got \".concat(typeof number, \": \").concat(number));\r\n        }\r\n        options = __assign({ bits: false, binary: false, space: true }, options);\r\n        var UNITS = options.bits\r\n            ? options.binary\r\n                ? BIBIT_UNITS\r\n                : BIT_UNITS\r\n            : options.binary\r\n                ? BIBYTE_UNITS\r\n                : BYTE_UNITS;\r\n        var separator = options.space ? ' ' : '';\r\n        if (options.signed && number === 0) {\r\n            return \" 0\".concat(separator).concat(UNITS[0]);\r\n        }\r\n        var isNegative = number < 0;\r\n        var prefix = isNegative ? '-' : options.signed ? '+' : '';\r\n        if (isNegative) {\r\n            number = -number;\r\n        }\r\n        var localeOptions;\r\n        if (options.minimumFractionDigits !== undefined) {\r\n            localeOptions = { minimumFractionDigits: options.minimumFractionDigits };\r\n        }\r\n        if (options.maximumFractionDigits !== undefined) {\r\n            localeOptions = __assign({ maximumFractionDigits: options.maximumFractionDigits }, localeOptions);\r\n        }\r\n        if (number < 1) {\r\n            var numberString_1 = toLocaleString(number, options.locale, localeOptions);\r\n            return prefix + numberString_1 + separator + UNITS[0];\r\n        }\r\n        var exponent = Math.min(Math.floor(options.binary ? Math.log(number) / Math.log(1024) : Math.log10(number) / 3), UNITS.length - 1);\r\n        number /= Math.pow((options.binary ? 1024 : 1000), exponent);\r\n        if (!localeOptions) {\r\n            number = number.toPrecision(3);\r\n        }\r\n        var numberString = toLocaleString(Number(number), options.locale, localeOptions);\r\n        var unit = UNITS[exponent];\r\n        return prefix + numberString + separator + unit;\r\n    },\r\n};\r\n"],"names":["__assign","this","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","BYTE_UNITS","BIBYTE_UNITS","BIT_UNITS","BIBIT_UNITS","toLocaleString","number","locale","options","result","Array","isArray","undefined","prettyBytes","UNITS","separator","prefix","localeOptions","exponent","Number","isFinite","bits","binary","space","signed","concat","isNegative","minimumFractionDigits","maximumFractionDigits","Math","min","floor","log","log10","pow","toPrecision","TypeError"],"mappings":"AAAA,IAAIA,SAAYC,MAAQA,KAAKD,UAAa,WAStC,OARAA,SAAWE,OAAOC,QAAU,SAASC,GACjC,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,CAAC,GAE7C,IAAK,IAAII,KADTL,EAAIG,UAAUF,GACOJ,OAAOS,UAAUC,eAAeC,KAAKR,EAAGK,CAAC,IAC1DN,EAAEM,GAAKL,EAAEK,IAEjB,OAAON,CACX,GACgBU,MAAMb,KAAMO,SAAS,CACzC,EACIO,WAAa,CAAC,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAC7DC,aAAe,CAAC,IAAK,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OACtEC,UAAY,CAAC,IAAK,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,QAC1EC,YAAc,CAAC,IAAK,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,SACnFC,eAAiB,SAAUC,EAAQC,EAAQC,GAC3C,IAAIC,EAASH,EAOb,MANsB,UAAlB,OAAOC,GAAuBG,MAAMC,QAAQJ,CAAM,EAClDE,EAASH,EAAOD,eAAeE,EAAQC,CAAO,EAE9B,CAAA,IAAXD,GAA+BK,KAAAA,IAAZJ,IACxBC,EAASH,EAAOD,eAAeO,KAAAA,EAAWJ,CAAO,GAE9CC,CACX,gBACe,CAUXI,YAAa,SAAUP,EAAQE,GAC3B,IAIIM,EAOAC,EAKAC,EAIAC,EAWAC,EA/BJ,GAAKC,OAAOC,SAASd,CAAM,EAY3B,OARIQ,GADJN,EAAUtB,SAAS,CAAEmC,KAAM,CAAA,EAAOC,OAAQ,CAAA,EAAOC,MAAO,CAAA,CAAK,EAAGf,CAAO,GACnDa,KACdb,EAAQc,OACJlB,YACAD,UACJK,EAAQc,OACJpB,aACAD,WACNc,EAAYP,EAAQe,MAAQ,IAAM,GAClCf,EAAQgB,QAAqB,IAAXlB,EACX,KAAKmB,OAAOV,CAAS,EAAEU,OAAOX,EAAM,EAAE,GAG7CE,GADAU,EAAapB,EAAS,GACA,IAAME,EAAQgB,OAAS,IAAM,GACnDE,IACApB,EAAS,CAACA,GAGwBM,KAAAA,IAAlCJ,EAAQmB,wBACRV,EAAgB,CAAEU,sBAAuBnB,EAAQmB,qBAAsB,GAErCf,KAAAA,IAAlCJ,EAAQoB,wBACRX,EAAgB/B,SAAS,CAAE0C,sBAAuBpB,EAAQoB,qBAAsB,EAAGX,CAAa,GAEhGX,EAAS,EAEFU,EADcX,eAAeC,EAAQE,EAAQD,OAAQU,CAAa,EACxCF,EAAYD,EAAM,IAEnDI,EAAWW,KAAKC,IAAID,KAAKE,MAAMvB,EAAQc,OAASO,KAAKG,IAAI1B,CAAM,EAAIuB,KAAKG,IAAI,IAAI,EAAIH,KAAKI,MAAM3B,CAAM,EAAI,CAAC,EAAGQ,EAAMnB,OAAS,CAAC,EACjIW,GAAUuB,KAAKK,IAAK1B,EAAQc,OAAS,KAAO,IAAOJ,CAAQ,EACtDD,IACDX,EAASA,EAAO6B,YAAY,CAAC,GAI1BnB,EAFYX,eAAec,OAAOb,CAAM,EAAGE,EAAQD,OAAQU,CAAa,EAEhDF,EADpBD,EAAMI,KApCb,MAAM,IAAIkB,UAAU,iCAAiCX,OAAO,OAAOnB,EAAQ,IAAI,EAAEmB,OAAOnB,CAAM,CAAC,CAsCvG,CACJ"}