{"version":3,"file":"util.js","sources":["util.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nimport MathUtil from '@baifendian/adhere-util/lib/math';\r\nexport default {\r\n    /**\r\n     * flyToChina - 设置地图的zoom为全中国\r\n     * @param map\r\n     */\r\n    flyToChina: function (map) {\r\n        // @ts-ignore\r\n        map.centerAndZoom(new BMap.Point(106.638754, 34.842904), 2);\r\n    },\r\n    /**\r\n     * fillCityBoundary - 根据city名字填充城市轮廓\r\n     * @param cityName\r\n     * @param style\r\n     * @param map\r\n     * @return\r\n     */\r\n    fillCityBoundary: function (cityName, style, map) {\r\n        var cityOverlays = [];\r\n        var cityPoints = [];\r\n        return new Promise(function (resolve) {\r\n            // 勾勒的轮廓\r\n            // @ts-ignore\r\n            var bd = new BMap.Boundary();\r\n            bd.get(cityName, function (rs) {\r\n                for (var i = 0; i < rs.boundaries.length; i++) {\r\n                    var boundarieStr = rs.boundaries[i];\r\n                    var boundarie = boundarieStr.split(';');\r\n                    boundarie.forEach(function (pointStr) {\r\n                        var point = pointStr.trim().split(',');\r\n                        cityPoints.push(\r\n                        // @ts-ignore\r\n                        new BMap.Point(parseFloat(point[0].trim()), parseFloat(point[1].trim())));\r\n                    });\r\n                    // @ts-ignore\r\n                    var hole = new BMap.Polygon(boundarieStr, __assign({}, style));\r\n                    // @ts-ignore\r\n                    cityOverlays.push(hole);\r\n                    map.addOverlay(hole);\r\n                }\r\n                resolve({\r\n                    cityOverlays: cityOverlays,\r\n                    cityPoints: cityPoints,\r\n                });\r\n            });\r\n        });\r\n    },\r\n    /**\r\n     * fit - 根据数据fit适应的zoom上\r\n     * @param map\r\n     * @param points\r\n     * @param config\r\n     */\r\n    // @ts-ignore\r\n    fit: function (map, points, config) {\r\n        return new Promise(function (resolve) {\r\n            var viewport = map.getViewport(points, config || {});\r\n            map.centerAndZoom(viewport.center, viewport.zoom);\r\n            setTimeout(function () {\r\n                resolve();\r\n            }, 200);\r\n        });\r\n    },\r\n    /**\r\n     * pixelToPoint - 像素坐标转换为经纬度坐标\r\n     * @param map\r\n     * @param pixel\r\n     */\r\n    pixelToPoint: function (map, pixel) {\r\n        return map.pixelToPoint(pixel);\r\n    },\r\n    /**\r\n     * pointToPixel - 经纬度坐标转换为像素坐标\r\n     * @param map\r\n     * @param point\r\n     */\r\n    pointToPixel: function (map, point) {\r\n        return map.pointToPixel(point);\r\n    },\r\n    /**\r\n     * getViewBound 获取当前视图的矩形范围坐标(坐上 | 右下)\r\n     * @param map\r\n     * @return {\r\n     *   leftTopLon\r\n     *   leftTopLat\r\n     *   rightBottomLon\r\n     *   rightBottomLat\r\n     * }\r\n     */\r\n    getBound: function (map) {\r\n        var bounds = map.getBounds();\r\n        //获取西南角的经纬度(左下端点)\r\n        var sw = bounds.getSouthWest();\r\n        //获取东北角的经纬度(右上端点)\r\n        var ne = bounds.getNorthEast();\r\n        return {\r\n            leftTopLon: sw.lng,\r\n            leftTopLat: ne.lat,\r\n            rightBottomLon: ne.lng,\r\n            rightBottomLat: sw.lat,\r\n        };\r\n    },\r\n    /**\r\n     * getScale - 根据zoom获取比例尺\r\n     * @param map\r\n     * @return number\r\n     */\r\n    getScale: function (map) {\r\n        // const zoom = map.getZoom();\r\n        //\r\n        // /**\r\n        //  * 比例尺的单位是(m)\r\n        //  */\r\n        // const zoomScaleMap = new Map([\r\n        //   [19, 20],\r\n        //   [18, 50],\r\n        //   [17, 10],\r\n        //   [16, 200],\r\n        //   [15, 500],\r\n        //   [14, 1000],\r\n        //   [13, 2000],\r\n        //   [12, 5000],\r\n        //   [11, 10000],\r\n        //   [10, 20000],\r\n        //   [9, 25000],\r\n        //   [8, 50000],\r\n        //   [7, 100000],\r\n        //   [6, 200000],\r\n        //   [5, 500000],\r\n        //   [4, 1000000],\r\n        //   [3, 2000000],\r\n        //   [2, 5000000],\r\n        //   [1, 10000000],\r\n        // ]);\r\n        //\r\n        // // @ts-ignore\r\n        // return 1 / zoomScaleMap.get(zoom);\r\n        // 根据输入范围值(单位：米) 计算出需要画的区域像素：px\r\n        var pointA = map.getCenter();\r\n        var pointAPixel = map.pointToOverlayPixel(pointA);\r\n        // @ts-ignore\r\n        var pointB = new BMap.Point(pointA.lng, pointA.lat + 0.001);\r\n        var pointBPixel = map.pointToOverlayPixel(pointB);\r\n        // 像素距离\r\n        var pixelDistanceBetween2Points = Math.abs(pointBPixel.y - pointAPixel.y);\r\n        var realDistanceBetween2Points = map.getDistance(pointA, pointB);\r\n        // 比例尺\r\n        return pixelDistanceBetween2Points / realDistanceBetween2Points;\r\n        // return this.getUnitPixelToM(map.getZoom());\r\n    },\r\n    /**\r\n     * getUnitPixelToM - 1px等于多少米(m)\r\n     * @param zoom\r\n     * @return number\r\n     */\r\n    getUnitPixelToM: function (zoom) {\r\n        return Math.pow(2, 18 - zoom);\r\n    },\r\n    /**\r\n     * getArrowPoints - 获取三角形三个顶点值\r\n     * @param from\r\n     * @param to\r\n     * @param scale\r\n     * @param width\r\n     * @param theta\r\n     * @return {{A: {x: number, y: number}, B: {x: number, y: number}, C: {x: number, y: number}}}\r\n     */\r\n    getArrowPoints: function (_a) {\r\n        var from = _a.from, to = _a.to, _b = _a.scale, scale = _b === void 0 ? 1 : _b, _c = _a.width, width = _c === void 0 ? 5 : _c, _d = _a.theta, theta = _d === void 0 ? 35 : _d;\r\n        var fromX = from.x, fromY = from.y;\r\n        var toX = to.x, toY = to.y;\r\n        var arrowX, arrowY; // 箭头线终点坐标\r\n        // 计算各角度和对应的箭头终点坐标\r\n        var angle = (Math.atan2(fromY - toY, fromX - toX) * 180) / Math.PI;\r\n        var angle1 = ((angle + theta) * Math.PI) / 180;\r\n        var angle2 = ((angle - theta) * Math.PI) / 180;\r\n        var topX = width * Math.cos(angle1);\r\n        var topY = width * Math.sin(angle1);\r\n        var botX = width * Math.cos(angle2);\r\n        var botY = width * Math.sin(angle2);\r\n        arrowX = toX + topX;\r\n        arrowY = toY + topY;\r\n        var A = {\r\n            x: arrowX * scale,\r\n            y: arrowY * scale,\r\n        };\r\n        var B = {\r\n            x: toX * scale,\r\n            y: toY * scale,\r\n        };\r\n        arrowX = toX + botX;\r\n        arrowY = toY + botY;\r\n        var C = {\r\n            x: arrowX * scale,\r\n            y: arrowY * scale,\r\n        };\r\n        return {\r\n            A: A,\r\n            B: B,\r\n            C: C,\r\n        };\r\n    },\r\n    clientToCtxPointToEl: function (_a) {\r\n        var event = _a.event, rect = _a.rect, offsetEl = _a.offsetEl;\r\n        var _b = window.getComputedStyle(offsetEl, null), left = _b.left, top = _b.top;\r\n        var offsetLeft = parseInt(left.replace('px', ''));\r\n        var offsetTop = parseInt(top.replace('px', ''));\r\n        return this.clientToCtxPoint({\r\n            event: event,\r\n            rect: rect,\r\n            offsetLeft: offsetLeft,\r\n            offsetTop: offsetTop,\r\n        });\r\n    },\r\n    clientToCtxPoint: function (_a) {\r\n        var event = _a.event, rect = _a.rect, offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;\r\n        var pixel = MathUtil.clientToCtxPoint({\r\n            event: event,\r\n            rect: rect,\r\n        });\r\n        pixel.x -= offsetLeft;\r\n        pixel.y -= offsetTop;\r\n        return pixel;\r\n    },\r\n};\r\n"],"names":["__assign","this","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","MathUtil","flyToChina","map","centerAndZoom","BMap","Point","fillCityBoundary","cityName","style","cityOverlays","cityPoints","Promise","resolve","Boundary","get","rs","boundaries","boundarieStr","split","forEach","pointStr","point","trim","push","parseFloat","hole","Polygon","addOverlay","fit","points","config","viewport","getViewport","center","zoom","setTimeout","pixelToPoint","pixel","pointToPixel","getBound","bounds","getBounds","sw","getSouthWest","ne","getNorthEast","leftTopLon","lng","leftTopLat","lat","rightBottomLon","rightBottomLat","getScale","pointA","getCenter","pointAPixel","pointToOverlayPixel","pointB","pointBPixel","Math","abs","y","getDistance","getUnitPixelToM","pow","getArrowPoints","_a","from","to","_b","scale","_c","width","_d","theta","fromX","x","fromY","toX","toY","angle","atan2","PI","angle1","angle2","arrowX","cos","arrowY","sin","A","B","C","clientToCtxPointToEl","event","rect","offsetEl","window","getComputedStyle","left","top","offsetLeft","parseInt","replace","offsetTop","clientToCtxPoint"],"mappings":"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"}