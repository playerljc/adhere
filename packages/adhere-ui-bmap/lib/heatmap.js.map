{"version":3,"file":"heatmap.js","sources":["heatmap.js"],"sourcesContent":["\"use strict\";\r\n/*\r\n * heatmap.js v2.0.0 | JavaScript Heatmap Library\r\n *\r\n * Copyright 2008-2014 Patrick Wied <heatmapjs@patrick-wied.at> - All rights reserved.\r\n * Dual licensed under MIT and Beerware license\r\n *\r\n * :: 2014-10-31 21:16\r\n */\r\n// (function (/*name, context,*/ factory) {\r\n//   // // Supports UMD. AMD, CommonJS/Node.js and browser context\r\n//   // if (typeof module !== 'undefined' && module.exports) {\r\n//   //   module.exports = factory();\r\n//   // } else if (typeof define === 'function' && define.amd) {\r\n//   //   define(factory);\r\n//   // } else {\r\n//   //   context[name] = factory();\r\n//   // }\r\n//   // context[name] = factory();\r\n//   // window['h337'] = factory();\r\n// })(\r\n//   /*'h337', this, */\r\n//     function () {\r\n//     // Heatmap Config stores default values and will be merged with instance config\r\n//     let  HeatmapConfig = {\r\n//       defaultRadius: 40,\r\n//       defaultRenderer: 'canvas2d',\r\n//       defaultGradient: {\r\n//         0.45: 'rgb(0,0,255)',\r\n//         0.55: 'rgb(0,255,255)',\r\n//         0.65: 'rgb(0,255,0)',\r\n//         0.95: 'yellow',\r\n//         1.0: 'rgb(255,0,0)',\r\n//       },\r\n//       defaultMaxOpacity: 1,\r\n//       defaultMinOpacity: 0,\r\n//       defaultBlur: 0.85,\r\n//       defaultXField: 'x',\r\n//       defaultYField: 'y',\r\n//       defaultValueField: 'value',\r\n//       plugins: {},\r\n//     };\r\n//     let  Store = (function StoreClosure() {\r\n//       let  Store = function Store(config) {\r\n//         this._coordinator = {};\r\n//         this._data = [];\r\n//         this._radi = [];\r\n//         this._min = 0;\r\n//         this._max = 1;\r\n//         this._xField = config['xField'] || config.defaultXField;\r\n//         this._yField = config['yField'] || config.defaultYField;\r\n//         this._valueField = config['valueField'] || config.defaultValueField;\r\n//\r\n//         if (config['radius']) {\r\n//           this._cfgRadius = config['radius'];\r\n//         }\r\n//       };\r\n//\r\n//       let  defaultRadius = HeatmapConfig.defaultRadius;\r\n//\r\n//       Store.prototype = {\r\n//         // when forceRender = false -> called from setData, omits renderall event\r\n//         _organiseData: function (dataPoint, forceRender) {\r\n//           let  x = dataPoint[this._xField];\r\n//           let  y = dataPoint[this._yField];\r\n//           let  radi = this._radi;\r\n//           let  store = this._data;\r\n//           let  max = this._max;\r\n//           let  min = this._min;\r\n//           let  value = dataPoint[this._valueField] || 1;\r\n//           let  radius = dataPoint.radius || this._cfgRadius || defaultRadius;\r\n//\r\n//           if (!store[x]) {\r\n//             store[x] = [];\r\n//             radi[x] = [];\r\n//           }\r\n//\r\n//           if (!store[x][y]) {\r\n//             store[x][y] = value;\r\n//             radi[x][y] = radius;\r\n//           } else {\r\n//             store[x][y] += value;\r\n//           }\r\n//\r\n//           if (store[x][y] > max) {\r\n//             if (!forceRender) {\r\n//               this._max = store[x][y];\r\n//             } else {\r\n//               this.setDataMax(store[x][y]);\r\n//             }\r\n//             return false;\r\n//           } else {\r\n//             return {\r\n//               x: x,\r\n//               y: y,\r\n//               value: value,\r\n//               radius: radius,\r\n//               min: min,\r\n//               max: max,\r\n//             };\r\n//           }\r\n//         },\r\n//         _unOrganizeData: function () {\r\n//           let  unorganizedData = [];\r\n//           let  data = this._data;\r\n//           let  radi = this._radi;\r\n//\r\n//           for (let  x in data) {\r\n//             for (let  y in data[x]) {\r\n//               unorganizedData.push({\r\n//                 x: x,\r\n//                 y: y,\r\n//                 radius: radi[x][y],\r\n//                 value: data[x][y],\r\n//               });\r\n//             }\r\n//           }\r\n//           return {\r\n//             min: this._min,\r\n//             max: this._max,\r\n//             data: unorganizedData,\r\n//           };\r\n//         },\r\n//         _onExtremaChange: function () {\r\n//           this._coordinator.emit('extremachange', {\r\n//             min: this._min,\r\n//             max: this._max,\r\n//           });\r\n//         },\r\n//         addData: function () {\r\n//           if (arguments[0].length > 0) {\r\n//             let  dataArr = arguments[0];\r\n//             let  dataLen = dataArr.length;\r\n//             while (dataLen--) {\r\n//               this.addData.call(this, dataArr[dataLen]);\r\n//             }\r\n//           } else {\r\n//             // add to store\r\n//             let  organisedEntry = this._organiseData(arguments[0], true);\r\n//             if (organisedEntry) {\r\n//               this._coordinator.emit('renderpartial', {\r\n//                 min: this._min,\r\n//                 max: this._max,\r\n//                 data: [organisedEntry],\r\n//               });\r\n//             }\r\n//           }\r\n//           return this;\r\n//         },\r\n//         setData: function (data) {\r\n//           let  dataPoints = data.data;\r\n//           let  pointsLen = dataPoints.length;\r\n//\r\n//           // reset data arrays\r\n//           this._data = [];\r\n//           this._radi = [];\r\n//\r\n//           for (let  i = 0; i < pointsLen; i++) {\r\n//             this._organiseData(dataPoints[i], false);\r\n//           }\r\n//           this._max = data.max;\r\n//           this._min = data.min || 0;\r\n//\r\n//           this._onExtremaChange();\r\n//           this._coordinator.emit('renderall', this._getInternalData());\r\n//           return this;\r\n//         },\r\n//         removeData: function () {\r\n//           // TODO: implement\r\n//         },\r\n//         setDataMax: function (max) {\r\n//           this._max = max;\r\n//           this._onExtremaChange();\r\n//           this._coordinator.emit('renderall', this._getInternalData());\r\n//           return this;\r\n//         },\r\n//         setDataMin: function (min) {\r\n//           this._min = min;\r\n//           this._onExtremaChange();\r\n//           this._coordinator.emit('renderall', this._getInternalData());\r\n//           return this;\r\n//         },\r\n//         setCoordinator: function (coordinator) {\r\n//           this._coordinator = coordinator;\r\n//         },\r\n//         _getInternalData: function () {\r\n//           return {\r\n//             max: this._max,\r\n//             min: this._min,\r\n//             data: this._data,\r\n//             radi: this._radi,\r\n//           };\r\n//         },\r\n//         getData: function () {\r\n//           return this._unOrganizeData();\r\n//         } /*,\r\n//\r\n//       TODO: rethink.\r\n//\r\n//     getValueAt: function(point) {\r\n//       let  value;\r\n//       let  radius = 100;\r\n//       let  x = point.x;\r\n//       let  y = point.y;\r\n//       let  data = this._data;\r\n//\r\n//       if (data[x] && data[x][y]) {\r\n//         return data[x][y];\r\n//       } else {\r\n//         let  values = [];\r\n//         // radial search for datapoints based on default radius\r\n//         for(let  distance = 1; distance < radius; distance++) {\r\n//           let  neighbors = distance * 2 +1;\r\n//           let  startX = x - distance;\r\n//           let  startY = y - distance;\r\n//\r\n//           for(let  i = 0; i < neighbors; i++) {\r\n//             for (let  o = 0; o < neighbors; o++) {\r\n//               if ((i == 0 || i == neighbors-1) || (o == 0 || o == neighbors-1)) {\r\n//                 if (data[startY+i] && data[startY+i][startX+o]) {\r\n//                   values.push(data[startY+i][startX+o]);\r\n//                 }\r\n//               } else {\r\n//                 continue;\r\n//               }\r\n//             }\r\n//           }\r\n//         }\r\n//         if (values.length > 0) {\r\n//           return Math.max.apply(Math, values);\r\n//         }\r\n//       }\r\n//       return false;\r\n//     }*/,\r\n//       };\r\n//\r\n//       return Store;\r\n//     })();\r\n//\r\n//     let  Canvas2dRenderer = (function Canvas2dRendererClosure() {\r\n//       let  _getColorPalette = function (config) {\r\n//         let  gradientConfig = config.gradient || config.defaultGradient;\r\n//         let  paletteCanvas = document.createElement('canvas');\r\n//         let  paletteCtx = paletteCanvas.getContext('2d');\r\n//\r\n//         paletteCanvas.width = 256;\r\n//         paletteCanvas.height = 1;\r\n//\r\n//         let  gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);\r\n//         for (let  key in gradientConfig) {\r\n//           gradient.addColorStop(key, gradientConfig[key]);\r\n//         }\r\n//\r\n//         paletteCtx.fillStyle = gradient;\r\n//         paletteCtx.fillRect(0, 0, 256, 1);\r\n//\r\n//         return paletteCtx.getImageData(0, 0, 256, 1).data;\r\n//       };\r\n//\r\n//       let  _getPointTemplate = function (radius, blurFactor) {\r\n//         let  tplCanvas = document.createElement('canvas');\r\n//         let  tplCtx = tplCanvas.getContext('2d');\r\n//         let  x = radius;\r\n//         let  y = radius;\r\n//         tplCanvas.width = tplCanvas.height = radius * 2;\r\n//\r\n//         if (blurFactor == 1) {\r\n//           tplCtx.beginPath();\r\n//           tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);\r\n//           tplCtx.fillStyle = 'rgba(0,0,0,1)';\r\n//           tplCtx.fill();\r\n//         } else {\r\n//           let  gradient = tplCtx.createRadialGradient(x, y, radius * blurFactor, x, y, radius);\r\n//           gradient.addColorStop(0, 'rgba(0,0,0,1)');\r\n//           gradient.addColorStop(1, 'rgba(0,0,0,0)');\r\n//           tplCtx.fillStyle = gradient;\r\n//           tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);\r\n//         }\r\n//\r\n//         return tplCanvas;\r\n//       };\r\n//\r\n//       let  _prepareData = function (data) {\r\n//         let  renderData = [];\r\n//         let  min = data.min;\r\n//         let  max = data.max;\r\n//         let  radi = data.radi;\r\n//         let  data = data.data;\r\n//\r\n//         let  xValues = Object.keys(data);\r\n//         let  xValuesLen = xValues.length;\r\n//\r\n//         while (xValuesLen--) {\r\n//           let  xValue = xValues[xValuesLen];\r\n//           let  yValues = Object.keys(data[xValue]);\r\n//           let  yValuesLen = yValues.length;\r\n//           while (yValuesLen--) {\r\n//             let  yValue = yValues[yValuesLen];\r\n//             let  value = data[xValue][yValue];\r\n//             let  radius = radi[xValue][yValue];\r\n//             renderData.push({\r\n//               x: xValue,\r\n//               y: yValue,\r\n//               value: value,\r\n//               radius: radius,\r\n//             });\r\n//           }\r\n//         }\r\n//\r\n//         return {\r\n//           min: min,\r\n//           max: max,\r\n//           data: renderData,\r\n//         };\r\n//       };\r\n//\r\n//       function Canvas2dRenderer(config) {\r\n//         let  container = config.element;\r\n//         let  shadowCanvas = (this.shadowCanvas = document.createElement('canvas'));\r\n//         let  canvas = (this.canvas = config.canvas || document.createElement('canvas'));\r\n//         let  renderBoundaries = (this._renderBoundaries = [10000, 10000, 0, 0]);\r\n//\r\n//         let  computed = getComputedStyle(config.element) || {};\r\n//\r\n//         canvas.className = 'heatmap-canvas';\r\n//\r\n//         this._width = canvas.width = shadowCanvas.width = +computed.width.replace(/px/, '');\r\n//         this._height = canvas.height = shadowCanvas.height = +computed.height.replace(/px/, '');\r\n//\r\n//         this.shadowCtx = shadowCanvas.getContext('2d');\r\n//         this.ctx = canvas.getContext('2d');\r\n//\r\n//         // @TODO:\r\n//         // conditional wrapper\r\n//\r\n//         canvas.style.cssText = shadowCanvas.style.cssText = 'position:absolute;left:0;top:0;';\r\n//\r\n//         container.style.position = 'relative';\r\n//         container.appendChild(canvas);\r\n//\r\n//         this._palette = _getColorPalette(config);\r\n//         this._templates = {};\r\n//\r\n//         this._setStyles(config);\r\n//       }\r\n//\r\n//       Canvas2dRenderer.prototype = {\r\n//         renderPartial: function (data) {\r\n//           this._drawAlpha(data);\r\n//           this._colorize();\r\n//         },\r\n//         renderAll: function (data) {\r\n//           // reset render boundaries\r\n//           this._clear();\r\n//           this._drawAlpha(_prepareData(data));\r\n//           this._colorize();\r\n//         },\r\n//         _updateGradient: function (config) {\r\n//           this._palette = _getColorPalette(config);\r\n//         },\r\n//         updateConfig: function (config) {\r\n//           if (config['gradient']) {\r\n//             this._updateGradient(config);\r\n//           }\r\n//           this._setStyles(config);\r\n//         },\r\n//         setDimensions: function (width, height) {\r\n//           this._width = width;\r\n//           this._height = height;\r\n//           this.canvas.width = this.shadowCanvas.width = width;\r\n//           this.canvas.height = this.shadowCanvas.height = height;\r\n//         },\r\n//         _clear: function () {\r\n//           this.shadowCtx.clearRect(0, 0, this._width, this._height);\r\n//           this.ctx.clearRect(0, 0, this._width, this._height);\r\n//         },\r\n//         _setStyles: function (config) {\r\n//           this._blur = config.blur == 0 ? 0 : config.blur || config.defaultBlur;\r\n//\r\n//           if (config.backgroundColor) {\r\n//             this.canvas.style.backgroundColor = config.backgroundColor;\r\n//           }\r\n//\r\n//           this._opacity = (config.opacity || 0) * 255;\r\n//           this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255;\r\n//           this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255;\r\n//           this._useGradientOpacity = !!config.useGradientOpacity;\r\n//         },\r\n//         _drawAlpha: function (data) {\r\n//           let  min = (this._min = data.min);\r\n//           let  max = (this._max = data.max);\r\n//           let  data = data.data || [];\r\n//           let  dataLen = data.length;\r\n//           // on a point basis?\r\n//           let  blur = 1 - this._blur;\r\n//\r\n//           while (dataLen--) {\r\n//             let  point = data[dataLen];\r\n//\r\n//             let  x = point.x;\r\n//             let  y = point.y;\r\n//             let  radius = point.radius;\r\n//             // if value is bigger than max\r\n//             // use max as value\r\n//             let  value = Math.min(point.value, max);\r\n//             let  rectX = x - radius;\r\n//             let  rectY = y - radius;\r\n//             let  shadowCtx = this.shadowCtx;\r\n//\r\n//             let  tpl;\r\n//             if (!this._templates[radius]) {\r\n//               this._templates[radius] = tpl = _getPointTemplate(radius, blur);\r\n//             } else {\r\n//               tpl = this._templates[radius];\r\n//             }\r\n//             // value from minimum / value range\r\n//             // => [0, 1]\r\n//             shadowCtx.globalAlpha = (value - min) / (max - min);\r\n//\r\n//             shadowCtx.drawImage(tpl, rectX, rectY);\r\n//\r\n//             // update renderBoundaries\r\n//             if (rectX < this._renderBoundaries[0]) {\r\n//               this._renderBoundaries[0] = rectX;\r\n//             }\r\n//             if (rectY < this._renderBoundaries[1]) {\r\n//               this._renderBoundaries[1] = rectY;\r\n//             }\r\n//             if (rectX + 2 * radius > this._renderBoundaries[2]) {\r\n//               this._renderBoundaries[2] = rectX + 2 * radius;\r\n//             }\r\n//             if (rectY + 2 * radius > this._renderBoundaries[3]) {\r\n//               this._renderBoundaries[3] = rectY + 2 * radius;\r\n//             }\r\n//           }\r\n//         },\r\n//         _colorize: function () {\r\n//           let  x = this._renderBoundaries[0];\r\n//           let  y = this._renderBoundaries[1];\r\n//           let  width = this._renderBoundaries[2] - x;\r\n//           let  height = this._renderBoundaries[3] - y;\r\n//           let  maxWidth = this._width;\r\n//           let  maxHeight = this._height;\r\n//           let  opacity = this._opacity;\r\n//           let  maxOpacity = this._maxOpacity;\r\n//           let  minOpacity = this._minOpacity;\r\n//           let  useGradientOpacity = this._useGradientOpacity;\r\n//\r\n//           if (x < 0) {\r\n//             x = 0;\r\n//           }\r\n//           if (y < 0) {\r\n//             y = 0;\r\n//           }\r\n//           if (x + width > maxWidth) {\r\n//             width = maxWidth - x;\r\n//           }\r\n//           if (y + height > maxHeight) {\r\n//             height = maxHeight - y;\r\n//           }\r\n//\r\n//           let  img = this.shadowCtx.getImageData(x, y, width, height);\r\n//           let  imgData = img.data;\r\n//           let  len = imgData.length;\r\n//           let  palette = this._palette;\r\n//\r\n//           for (let  i = 3; i < len; i += 4) {\r\n//             let  alpha = imgData[i];\r\n//             let  offset = alpha * 4;\r\n//\r\n//             if (!offset) {\r\n//               continue;\r\n//             }\r\n//\r\n//             let  finalAlpha;\r\n//             if (opacity > 0) {\r\n//               finalAlpha = opacity;\r\n//             } else {\r\n//               if (alpha < maxOpacity) {\r\n//                 if (alpha < minOpacity) {\r\n//                   finalAlpha = minOpacity;\r\n//                 } else {\r\n//                   finalAlpha = alpha;\r\n//                 }\r\n//               } else {\r\n//                 finalAlpha = maxOpacity;\r\n//               }\r\n//             }\r\n//\r\n//             imgData[i - 3] = palette[offset];\r\n//             imgData[i - 2] = palette[offset + 1];\r\n//             imgData[i - 1] = palette[offset + 2];\r\n//             imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;\r\n//           }\r\n//\r\n//           img.data = imgData;\r\n//           this.ctx.putImageData(img, x, y);\r\n//\r\n//           this._renderBoundaries = [1000, 1000, 0, 0];\r\n//         },\r\n//         getValueAt: function (point) {\r\n//           let  value;\r\n//           let  shadowCtx = this.shadowCtx;\r\n//           let  img = shadowCtx.getImageData(point.x, point.y, 1, 1);\r\n//           let  data = img.data[3];\r\n//           let  max = this._max;\r\n//           let  min = this._min;\r\n//\r\n//           value = (Math.abs(max - min) * (data / 255)) >> 0;\r\n//\r\n//           return value;\r\n//         },\r\n//         getDataURL: function () {\r\n//           return this.canvas.toDataURL();\r\n//         },\r\n//       };\r\n//\r\n//       return Canvas2dRenderer;\r\n//     })();\r\n//\r\n//     let  Renderer = (function RendererClosure() {\r\n//       let  rendererFn = false;\r\n//\r\n//       if (HeatmapConfig['defaultRenderer'] === 'canvas2d') {\r\n//         rendererFn = Canvas2dRenderer;\r\n//       }\r\n//\r\n//       return rendererFn;\r\n//     })();\r\n//\r\n//     let  Util = {\r\n//       merge: function () {\r\n//         let  merged = {};\r\n//         let  argsLen = arguments.length;\r\n//         for (let  i = 0; i < argsLen; i++) {\r\n//           let  obj = arguments[i];\r\n//           for (let  key in obj) {\r\n//             merged[key] = obj[key];\r\n//           }\r\n//         }\r\n//         return merged;\r\n//       },\r\n//     };\r\n//     // Heatmap Constructor\r\n//     let  Heatmap = (function HeatmapClosure() {\r\n//       let  Coordinator = (function CoordinatorClosure() {\r\n//         function Coordinator() {\r\n//           this.cStore = {};\r\n//         }\r\n//\r\n//         Coordinator.prototype = {\r\n//           on: function (evtName, callback, scope) {\r\n//             let  cStore = this.cStore;\r\n//\r\n//             if (!cStore[evtName]) {\r\n//               cStore[evtName] = [];\r\n//             }\r\n//             cStore[evtName].push(function (data) {\r\n//               return callback.call(scope, data);\r\n//             });\r\n//           },\r\n//           emit: function (evtName, data) {\r\n//             let  cStore = this.cStore;\r\n//             if (cStore[evtName]) {\r\n//               let  len = cStore[evtName].length;\r\n//               for (let  i = 0; i < len; i++) {\r\n//                 let  callback = cStore[evtName][i];\r\n//                 callback(data);\r\n//               }\r\n//             }\r\n//           },\r\n//         };\r\n//\r\n//         return Coordinator;\r\n//       })();\r\n//\r\n//       let  _connect = function (scope) {\r\n//         let  renderer = scope._renderer;\r\n//         let  coordinator = scope._coordinator;\r\n//         let  store = scope._store;\r\n//\r\n//         coordinator.on('renderpartial', renderer.renderPartial, renderer);\r\n//         coordinator.on('renderall', renderer.renderAll, renderer);\r\n//         coordinator.on('extremachange', function (data) {\r\n//           scope._config.onExtremaChange &&\r\n//             scope._config.onExtremaChange({\r\n//               min: data.min,\r\n//               max: data.max,\r\n//               gradient: scope._config['gradient'] || scope._config['defaultGradient'],\r\n//             });\r\n//         });\r\n//         store.setCoordinator(coordinator);\r\n//       };\r\n//\r\n//       function Heatmap() {\r\n//         let  config = (this._config = Util.merge(HeatmapConfig, arguments[0] || {}));\r\n//         this._coordinator = new Coordinator();\r\n//         if (config['plugin']) {\r\n//           let  pluginToLoad = config['plugin'];\r\n//           if (!HeatmapConfig.plugins[pluginToLoad]) {\r\n//             throw new Error(\r\n//               \"Plugin '\" + pluginToLoad + \"' not found. Maybe it was not registered.\",\r\n//             );\r\n//           } else {\r\n//             let  plugin = HeatmapConfig.plugins[pluginToLoad];\r\n//             // set plugin renderer and store\r\n//             this._renderer = new plugin.renderer(config);\r\n//             this._store = new plugin.store(config);\r\n//           }\r\n//         } else {\r\n//           this._renderer = new Renderer(config);\r\n//           this._store = new Store(config);\r\n//         }\r\n//         _connect(this);\r\n//       }\r\n//\r\n//       // @TODO:\r\n//       // add API documentation\r\n//       Heatmap.prototype = {\r\n//         addData: function () {\r\n//           this._store.addData.apply(this._store, arguments);\r\n//           return this;\r\n//         },\r\n//         removeData: function () {\r\n//           this._store.removeData && this._store.removeData.apply(this._store, arguments);\r\n//           return this;\r\n//         },\r\n//         setData: function () {\r\n//           this._store.setData.apply(this._store, arguments);\r\n//           return this;\r\n//         },\r\n//         setDataMax: function () {\r\n//           this._store.setDataMax.apply(this._store, arguments);\r\n//           return this;\r\n//         },\r\n//         setDataMin: function () {\r\n//           this._store.setDataMin.apply(this._store, arguments);\r\n//           return this;\r\n//         },\r\n//         configure: function (config) {\r\n//           this._config = Util.merge(this._config, config);\r\n//           this._renderer.updateConfig(this._config);\r\n//           this._coordinator.emit('renderall', this._store._getInternalData());\r\n//           return this;\r\n//         },\r\n//         repaint: function () {\r\n//           this._coordinator.emit('renderall', this._store._getInternalData());\r\n//           return this;\r\n//         },\r\n//         getData: function () {\r\n//           return this._store.getData();\r\n//         },\r\n//         getDataURL: function () {\r\n//           return this._renderer.getDataURL();\r\n//         },\r\n//         getValueAt: function (point) {\r\n//           if (this._store.getValueAt) {\r\n//             return this._store.getValueAt(point);\r\n//           } else if (this._renderer.getValueAt) {\r\n//             return this._renderer.getValueAt(point);\r\n//           } else {\r\n//             return null;\r\n//           }\r\n//         },\r\n//       };\r\n//\r\n//       return Heatmap;\r\n//     })();\r\n//\r\n//     // core\r\n//     let  heatmapFactory = {\r\n//       create: function (config) {\r\n//         return new Heatmap(config);\r\n//       },\r\n//       register: function (pluginKey, plugin) {\r\n//         HeatmapConfig.plugins[pluginKey] = plugin;\r\n//       },\r\n//     };\r\n//\r\n//     return heatmapFactory;\r\n//   },\r\n// );\r\n/*==============================以上部分为heatmap.js的核心代码,只负责热力图的展现====================================*/\r\n/*==============================以下部分为专为百度地图打造的覆盖物===================================================*/\r\n/**\r\n * @fileoverview 百度地图的热力图功能,对外开放。\r\n * 主要基于http://www.patrick-wied.at/static/heatmapjs/index.html 修改而得\r\n\r\n * 主入口类是<a href=\"symbols/BMapLib.Heatmap.html\">Heatmap</a>，\r\n * 基于Baidu Map API 2.0。\r\n *\r\n * @author Baidu Map Api Group\r\n * @version 1.0\r\n */\r\nfunction create() {\r\n    // Heatmap Config stores default values and will be merged with instance config\r\n    var HeatmapConfig = {\r\n        defaultRadius: 40,\r\n        defaultRenderer: 'canvas2d',\r\n        defaultGradient: {\r\n            0.45: 'rgb(0,0,255)',\r\n            0.55: 'rgb(0,255,255)',\r\n            0.65: 'rgb(0,255,0)',\r\n            0.95: 'yellow',\r\n            1.0: 'rgb(255,0,0)',\r\n        },\r\n        defaultMaxOpacity: 1,\r\n        defaultMinOpacity: 0,\r\n        defaultBlur: 0.85,\r\n        defaultXField: 'x',\r\n        defaultYField: 'y',\r\n        defaultValueField: 'value',\r\n        plugins: {},\r\n    };\r\n    var Store = (function StoreClosure() {\r\n        var Store = function Store(config) {\r\n            this._coordinator = {};\r\n            this._data = [];\r\n            this._radi = [];\r\n            this._min = 0;\r\n            this._max = 1;\r\n            this._xField = config['xField'] || config.defaultXField;\r\n            this._yField = config['yField'] || config.defaultYField;\r\n            this._valueField = config['valueField'] || config.defaultValueField;\r\n            if (config['radius']) {\r\n                this._cfgRadius = config['radius'];\r\n            }\r\n        };\r\n        var defaultRadius = HeatmapConfig.defaultRadius;\r\n        Store.prototype = {\r\n            // when forceRender = false -> called from setData, omits renderall event\r\n            _organiseData: function (dataPoint, forceRender) {\r\n                var x = dataPoint[this._xField];\r\n                var y = dataPoint[this._yField];\r\n                var radi = this._radi;\r\n                var store = this._data;\r\n                var max = this._max;\r\n                var min = this._min;\r\n                var value = dataPoint[this._valueField] || 1;\r\n                var radius = dataPoint.radius || this._cfgRadius || defaultRadius;\r\n                if (!store[x]) {\r\n                    store[x] = [];\r\n                    radi[x] = [];\r\n                }\r\n                if (!store[x][y]) {\r\n                    store[x][y] = value;\r\n                    radi[x][y] = radius;\r\n                }\r\n                else {\r\n                    store[x][y] += value;\r\n                }\r\n                if (store[x][y] > max) {\r\n                    if (!forceRender) {\r\n                        this._max = store[x][y];\r\n                    }\r\n                    else {\r\n                        this.setDataMax(store[x][y]);\r\n                    }\r\n                    return false;\r\n                }\r\n                else {\r\n                    return {\r\n                        x: x,\r\n                        y: y,\r\n                        value: value,\r\n                        radius: radius,\r\n                        min: min,\r\n                        max: max,\r\n                    };\r\n                }\r\n            },\r\n            _unOrganizeData: function () {\r\n                var unorganizedData = [];\r\n                var data = this._data;\r\n                var radi = this._radi;\r\n                for (var x in data) {\r\n                    for (var y in data[x]) {\r\n                        unorganizedData.push({\r\n                            x: x,\r\n                            y: y,\r\n                            radius: radi[x][y],\r\n                            value: data[x][y],\r\n                        });\r\n                    }\r\n                }\r\n                return {\r\n                    min: this._min,\r\n                    max: this._max,\r\n                    data: unorganizedData,\r\n                };\r\n            },\r\n            _onExtremaChange: function () {\r\n                this._coordinator.emit('extremachange', {\r\n                    min: this._min,\r\n                    max: this._max,\r\n                });\r\n            },\r\n            addData: function () {\r\n                if (arguments[0].length > 0) {\r\n                    var dataArr = arguments[0];\r\n                    var dataLen = dataArr.length;\r\n                    while (dataLen--) {\r\n                        this.addData.call(this, dataArr[dataLen]);\r\n                    }\r\n                }\r\n                else {\r\n                    // add to store\r\n                    var organisedEntry = this._organiseData(arguments[0], true);\r\n                    if (organisedEntry) {\r\n                        this._coordinator.emit('renderpartial', {\r\n                            min: this._min,\r\n                            max: this._max,\r\n                            data: [organisedEntry],\r\n                        });\r\n                    }\r\n                }\r\n                return this;\r\n            },\r\n            setData: function (data) {\r\n                var dataPoints = data.data;\r\n                var pointsLen = dataPoints.length;\r\n                // reset data arrays\r\n                this._data = [];\r\n                this._radi = [];\r\n                for (var i = 0; i < pointsLen; i++) {\r\n                    this._organiseData(dataPoints[i], false);\r\n                }\r\n                this._max = data.max;\r\n                this._min = data.min || 0;\r\n                this._onExtremaChange();\r\n                this._coordinator.emit('renderall', this._getInternalData());\r\n                return this;\r\n            },\r\n            removeData: function () {\r\n                // TODO: implement\r\n            },\r\n            setDataMax: function (max) {\r\n                this._max = max;\r\n                this._onExtremaChange();\r\n                this._coordinator.emit('renderall', this._getInternalData());\r\n                return this;\r\n            },\r\n            setDataMin: function (min) {\r\n                this._min = min;\r\n                this._onExtremaChange();\r\n                this._coordinator.emit('renderall', this._getInternalData());\r\n                return this;\r\n            },\r\n            setCoordinator: function (coordinator) {\r\n                this._coordinator = coordinator;\r\n            },\r\n            _getInternalData: function () {\r\n                return {\r\n                    max: this._max,\r\n                    min: this._min,\r\n                    data: this._data,\r\n                    radi: this._radi,\r\n                };\r\n            },\r\n            getData: function () {\r\n                return this._unOrganizeData();\r\n            } /*,\r\n      \r\n            TODO: rethink.\r\n      \r\n          getValueAt: function(point) {\r\n            var   value;\r\n            var   radius = 100;\r\n            var   x = point.x;\r\n            var   y = point.y;\r\n            var   data = this._data;\r\n      \r\n            if (data[x] && data[x][y]) {\r\n              return data[x][y];\r\n            } else {\r\n              var   values = [];\r\n              // radial search for datapoints based on default radius\r\n              for(var   distance = 1; distance < radius; distance++) {\r\n                var   neighbors = distance * 2 +1;\r\n                var   startX = x - distance;\r\n                var   startY = y - distance;\r\n      \r\n                for(var   i = 0; i < neighbors; i++) {\r\n                  for (var   o = 0; o < neighbors; o++) {\r\n                    if ((i == 0 || i == neighbors-1) || (o == 0 || o == neighbors-1)) {\r\n                      if (data[startY+i] && data[startY+i][startX+o]) {\r\n                        values.push(data[startY+i][startX+o]);\r\n                      }\r\n                    } else {\r\n                      continue;\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              if (values.length > 0) {\r\n                return Math.max.apply(Math, values);\r\n              }\r\n            }\r\n            return false;\r\n          }*/,\r\n        };\r\n        return Store;\r\n    })();\r\n    var Canvas2dRenderer = (function Canvas2dRendererClosure() {\r\n        var _getColorPalette = function (config) {\r\n            var gradientConfig = config.gradient || config.defaultGradient;\r\n            var paletteCanvas = document.createElement('canvas');\r\n            var paletteCtx = paletteCanvas.getContext('2d');\r\n            paletteCanvas.width = 256;\r\n            paletteCanvas.height = 1;\r\n            var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);\r\n            for (var key in gradientConfig) {\r\n                gradient.addColorStop(key, gradientConfig[key]);\r\n            }\r\n            paletteCtx.fillStyle = gradient;\r\n            paletteCtx.fillRect(0, 0, 256, 1);\r\n            return paletteCtx.getImageData(0, 0, 256, 1).data;\r\n        };\r\n        var _getPointTemplate = function (radius, blurFactor) {\r\n            var tplCanvas = document.createElement('canvas');\r\n            var tplCtx = tplCanvas.getContext('2d');\r\n            var x = radius;\r\n            var y = radius;\r\n            tplCanvas.width = tplCanvas.height = radius * 2;\r\n            if (blurFactor == 1) {\r\n                tplCtx.beginPath();\r\n                tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);\r\n                tplCtx.fillStyle = 'rgba(0,0,0,1)';\r\n                tplCtx.fill();\r\n            }\r\n            else {\r\n                var gradient = tplCtx.createRadialGradient(x, y, radius * blurFactor, x, y, radius);\r\n                gradient.addColorStop(0, 'rgba(0,0,0,1)');\r\n                gradient.addColorStop(1, 'rgba(0,0,0,0)');\r\n                tplCtx.fillStyle = gradient;\r\n                tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);\r\n            }\r\n            return tplCanvas;\r\n        };\r\n        var _prepareData = function (data) {\r\n            var renderData = [];\r\n            var min = data.min;\r\n            var max = data.max;\r\n            var radi = data.radi;\r\n            var data = data.data;\r\n            var xValues = Object.keys(data);\r\n            var xValuesLen = xValues.length;\r\n            while (xValuesLen--) {\r\n                var xValue = xValues[xValuesLen];\r\n                var yValues = Object.keys(data[xValue]);\r\n                var yValuesLen = yValues.length;\r\n                while (yValuesLen--) {\r\n                    var yValue = yValues[yValuesLen];\r\n                    var value = data[xValue][yValue];\r\n                    var radius = radi[xValue][yValue];\r\n                    renderData.push({\r\n                        x: xValue,\r\n                        y: yValue,\r\n                        value: value,\r\n                        radius: radius,\r\n                    });\r\n                }\r\n            }\r\n            return {\r\n                min: min,\r\n                max: max,\r\n                data: renderData,\r\n            };\r\n        };\r\n        function Canvas2dRenderer(config) {\r\n            var container = config.element;\r\n            var shadowCanvas = (this.shadowCanvas = document.createElement('canvas'));\r\n            var canvas = (this.canvas = config.canvas || document.createElement('canvas'));\r\n            var renderBoundaries = (this._renderBoundaries = [10000, 10000, 0, 0]);\r\n            var computed = getComputedStyle(config.element) || {};\r\n            canvas.className = 'heatmap-canvas';\r\n            this._width = canvas.width = shadowCanvas.width = +computed.width.replace(/px/, '');\r\n            this._height = canvas.height = shadowCanvas.height = +computed.height.replace(/px/, '');\r\n            this.shadowCtx = shadowCanvas.getContext('2d');\r\n            this.ctx = canvas.getContext('2d');\r\n            // @TODO:\r\n            // conditional wrapper\r\n            canvas.style.cssText = shadowCanvas.style.cssText = 'position:absolute;left:0;top:0;';\r\n            container.style.position = 'relative';\r\n            container.appendChild(canvas);\r\n            this._palette = _getColorPalette(config);\r\n            this._templates = {};\r\n            this._setStyles(config);\r\n        }\r\n        Canvas2dRenderer.prototype = {\r\n            renderPartial: function (data) {\r\n                this._drawAlpha(data);\r\n                this._colorize();\r\n            },\r\n            renderAll: function (data) {\r\n                // reset render boundaries\r\n                this._clear();\r\n                this._drawAlpha(_prepareData(data));\r\n                this._colorize();\r\n            },\r\n            _updateGradient: function (config) {\r\n                this._palette = _getColorPalette(config);\r\n            },\r\n            updateConfig: function (config) {\r\n                if (config['gradient']) {\r\n                    this._updateGradient(config);\r\n                }\r\n                this._setStyles(config);\r\n            },\r\n            setDimensions: function (width, height) {\r\n                this._width = width;\r\n                this._height = height;\r\n                this.canvas.width = this.shadowCanvas.width = width;\r\n                this.canvas.height = this.shadowCanvas.height = height;\r\n            },\r\n            _clear: function () {\r\n                this.shadowCtx.clearRect(0, 0, this._width, this._height);\r\n                this.ctx.clearRect(0, 0, this._width, this._height);\r\n            },\r\n            _setStyles: function (config) {\r\n                this._blur = config.blur == 0 ? 0 : config.blur || config.defaultBlur;\r\n                if (config.backgroundColor) {\r\n                    this.canvas.style.backgroundColor = config.backgroundColor;\r\n                }\r\n                this._opacity = (config.opacity || 0) * 255;\r\n                this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255;\r\n                this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255;\r\n                this._useGradientOpacity = !!config.useGradientOpacity;\r\n            },\r\n            _drawAlpha: function (data) {\r\n                var min = (this._min = data.min);\r\n                var max = (this._max = data.max);\r\n                var data = data.data || [];\r\n                var dataLen = data.length;\r\n                // on a point basis?\r\n                var blur = 1 - this._blur;\r\n                while (dataLen--) {\r\n                    var point = data[dataLen];\r\n                    var x = point.x;\r\n                    var y = point.y;\r\n                    var radius = point.radius;\r\n                    // if value is bigger than max\r\n                    // use max as value\r\n                    var value = Math.min(point.value, max);\r\n                    var rectX = x - radius;\r\n                    var rectY = y - radius;\r\n                    var shadowCtx = this.shadowCtx;\r\n                    var tpl;\r\n                    if (!this._templates[radius]) {\r\n                        this._templates[radius] = tpl = _getPointTemplate(radius, blur);\r\n                    }\r\n                    else {\r\n                        tpl = this._templates[radius];\r\n                    }\r\n                    // value from minimum / value range\r\n                    // => [0, 1]\r\n                    shadowCtx.globalAlpha = (value - min) / (max - min);\r\n                    shadowCtx.drawImage(tpl, rectX, rectY);\r\n                    // update renderBoundaries\r\n                    if (rectX < this._renderBoundaries[0]) {\r\n                        this._renderBoundaries[0] = rectX;\r\n                    }\r\n                    if (rectY < this._renderBoundaries[1]) {\r\n                        this._renderBoundaries[1] = rectY;\r\n                    }\r\n                    if (rectX + 2 * radius > this._renderBoundaries[2]) {\r\n                        this._renderBoundaries[2] = rectX + 2 * radius;\r\n                    }\r\n                    if (rectY + 2 * radius > this._renderBoundaries[3]) {\r\n                        this._renderBoundaries[3] = rectY + 2 * radius;\r\n                    }\r\n                }\r\n            },\r\n            _colorize: function () {\r\n                var x = this._renderBoundaries[0];\r\n                var y = this._renderBoundaries[1];\r\n                var width = this._renderBoundaries[2] - x;\r\n                var height = this._renderBoundaries[3] - y;\r\n                var maxWidth = this._width;\r\n                var maxHeight = this._height;\r\n                var opacity = this._opacity;\r\n                var maxOpacity = this._maxOpacity;\r\n                var minOpacity = this._minOpacity;\r\n                var useGradientOpacity = this._useGradientOpacity;\r\n                if (x < 0) {\r\n                    x = 0;\r\n                }\r\n                if (y < 0) {\r\n                    y = 0;\r\n                }\r\n                if (x + width > maxWidth) {\r\n                    width = maxWidth - x;\r\n                }\r\n                if (y + height > maxHeight) {\r\n                    height = maxHeight - y;\r\n                }\r\n                var img = this.shadowCtx.getImageData(x, y, width, height);\r\n                var imgData = img.data;\r\n                var len = imgData.length;\r\n                var palette = this._palette;\r\n                for (var i = 3; i < len; i += 4) {\r\n                    var alpha = imgData[i];\r\n                    var offset = alpha * 4;\r\n                    if (!offset) {\r\n                        continue;\r\n                    }\r\n                    var finalAlpha;\r\n                    if (opacity > 0) {\r\n                        finalAlpha = opacity;\r\n                    }\r\n                    else {\r\n                        if (alpha < maxOpacity) {\r\n                            if (alpha < minOpacity) {\r\n                                finalAlpha = minOpacity;\r\n                            }\r\n                            else {\r\n                                finalAlpha = alpha;\r\n                            }\r\n                        }\r\n                        else {\r\n                            finalAlpha = maxOpacity;\r\n                        }\r\n                    }\r\n                    imgData[i - 3] = palette[offset];\r\n                    imgData[i - 2] = palette[offset + 1];\r\n                    imgData[i - 1] = palette[offset + 2];\r\n                    imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;\r\n                }\r\n                // img.data = imgData;\r\n                this.ctx.putImageData(img, x, y);\r\n                this._renderBoundaries = [1000, 1000, 0, 0];\r\n            },\r\n            getValueAt: function (point) {\r\n                var value;\r\n                var shadowCtx = this.shadowCtx;\r\n                var img = shadowCtx.getImageData(point.x, point.y, 1, 1);\r\n                var data = img.data[3];\r\n                var max = this._max;\r\n                var min = this._min;\r\n                value = (Math.abs(max - min) * (data / 255)) >> 0;\r\n                return value;\r\n            },\r\n            getDataURL: function () {\r\n                return this.canvas.toDataURL();\r\n            },\r\n        };\r\n        return Canvas2dRenderer;\r\n    })();\r\n    var Renderer = (function RendererClosure() {\r\n        var rendererFn = false;\r\n        if (HeatmapConfig['defaultRenderer'] === 'canvas2d') {\r\n            rendererFn = Canvas2dRenderer;\r\n        }\r\n        return rendererFn;\r\n    })();\r\n    var Util = {\r\n        merge: function () {\r\n            var merged = {};\r\n            var argsLen = arguments.length;\r\n            for (var i = 0; i < argsLen; i++) {\r\n                var obj = arguments[i];\r\n                for (var key in obj) {\r\n                    merged[key] = obj[key];\r\n                }\r\n            }\r\n            return merged;\r\n        },\r\n    };\r\n    // Heatmap Constructor\r\n    var Heatmap = (function HeatmapClosure() {\r\n        var Coordinator = (function CoordinatorClosure() {\r\n            function Coordinator() {\r\n                this.cStore = {};\r\n            }\r\n            Coordinator.prototype = {\r\n                on: function (evtName, callback, scope) {\r\n                    var cStore = this.cStore;\r\n                    if (!cStore[evtName]) {\r\n                        cStore[evtName] = [];\r\n                    }\r\n                    cStore[evtName].push(function (data) {\r\n                        return callback.call(scope, data);\r\n                    });\r\n                },\r\n                emit: function (evtName, data) {\r\n                    var cStore = this.cStore;\r\n                    if (cStore[evtName]) {\r\n                        var len = cStore[evtName].length;\r\n                        for (var i = 0; i < len; i++) {\r\n                            var callback = cStore[evtName][i];\r\n                            callback(data);\r\n                        }\r\n                    }\r\n                },\r\n            };\r\n            return Coordinator;\r\n        })();\r\n        var _connect = function (scope) {\r\n            var renderer = scope._renderer;\r\n            var coordinator = scope._coordinator;\r\n            var store = scope._store;\r\n            coordinator.on('renderpartial', renderer.renderPartial, renderer);\r\n            coordinator.on('renderall', renderer.renderAll, renderer);\r\n            coordinator.on('extremachange', function (data) {\r\n                scope._config.onExtremaChange &&\r\n                    scope._config.onExtremaChange({\r\n                        min: data.min,\r\n                        max: data.max,\r\n                        gradient: scope._config['gradient'] || scope._config['defaultGradient'],\r\n                    });\r\n            });\r\n            store.setCoordinator(coordinator);\r\n        };\r\n        function Heatmap() {\r\n            var config = (this._config = Util.merge(HeatmapConfig, arguments[0] || {}));\r\n            this._coordinator = new Coordinator();\r\n            if (config['plugin']) {\r\n                var pluginToLoad = config['plugin'];\r\n                if (!HeatmapConfig.plugins[pluginToLoad]) {\r\n                    throw new Error(\"Plugin '\" + pluginToLoad + \"' not found. Maybe it was not registered.\");\r\n                }\r\n                else {\r\n                    var plugin = HeatmapConfig.plugins[pluginToLoad];\r\n                    // set plugin renderer and store\r\n                    this._renderer = new plugin.renderer(config);\r\n                    this._store = new plugin.store(config);\r\n                }\r\n            }\r\n            else {\r\n                this._renderer = new Renderer(config);\r\n                this._store = new Store(config);\r\n            }\r\n            _connect(this);\r\n        }\r\n        // @TODO:\r\n        // add API documentation\r\n        Heatmap.prototype = {\r\n            addData: function () {\r\n                this._store.addData.apply(this._store, arguments);\r\n                return this;\r\n            },\r\n            removeData: function () {\r\n                this._store.removeData && this._store.removeData.apply(this._store, arguments);\r\n                return this;\r\n            },\r\n            setData: function () {\r\n                this._store.setData.apply(this._store, arguments);\r\n                return this;\r\n            },\r\n            setDataMax: function () {\r\n                this._store.setDataMax.apply(this._store, arguments);\r\n                return this;\r\n            },\r\n            setDataMin: function () {\r\n                this._store.setDataMin.apply(this._store, arguments);\r\n                return this;\r\n            },\r\n            configure: function (config) {\r\n                this._config = Util.merge(this._config, config);\r\n                this._renderer.updateConfig(this._config);\r\n                this._coordinator.emit('renderall', this._store._getInternalData());\r\n                return this;\r\n            },\r\n            repaint: function () {\r\n                this._coordinator.emit('renderall', this._store._getInternalData());\r\n                return this;\r\n            },\r\n            getData: function () {\r\n                return this._store.getData();\r\n            },\r\n            getDataURL: function () {\r\n                return this._renderer.getDataURL();\r\n            },\r\n            getValueAt: function (point) {\r\n                if (this._store.getValueAt) {\r\n                    return this._store.getValueAt(point);\r\n                }\r\n                else if (this._renderer.getValueAt) {\r\n                    return this._renderer.getValueAt(point);\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            },\r\n        };\r\n        return Heatmap;\r\n    })();\r\n    // core\r\n    var heatmapFactory = {\r\n        create: function (config) {\r\n            return new Heatmap(config);\r\n        },\r\n        register: function (pluginKey, plugin) {\r\n            HeatmapConfig.plugins[pluginKey] = plugin;\r\n        },\r\n    };\r\n    return heatmapFactory;\r\n}\r\nvar h337 = create();\r\n/**\r\n * @namespace BMap的所有library类均放在BMapLib命名空间下\r\n */\r\nvar BMapLib = (window.BMapLib = BMapLib || {});\r\n(function () {\r\n    /**\r\n     * @exports HeatmapOverlay as BMapLib.HeatmapOverlay\r\n     */\r\n    var HeatmapOverlay = \r\n    /**\r\n     * 热力图的覆盖物\r\n     * @class 热力图的覆盖物\r\n     * 实例化该类后，使用map.addOverlay即可以添加热力图\r\n     *\r\n     * @constructor\r\n     * @param {Json Object} opts 可选的输入参数，非必填项。可输入选项包括：<br />\r\n     * {\"<b>radius</b>\" : {String} 热力图的半径,\r\n     * <br />\"<b>visible</b>\" : {Number} 热力图是否显示,\r\n     * <br />\"<b>gradient</b>\" : {JSON} 热力图的渐变区间,\r\n     * <br />\"<b>opacity</b>\" : {Number} 热力的透明度,\r\n     *\r\n     * @example <b>参考示例：</b><br />\r\n     * var   map = new BMap.Map(\"container\");<br />map.centerAndZoom(new BMap.Point(116.404, 39.915), 15);<br />var   heatmapOverlay = new BMapLib.HeatmapOverlay({\"radius\":10, \"visible\":true, \"opacity\":70});<br />heatmapOverlay.setDataSet(data);//data是热力图的详细数据\r\n     */\r\n    (BMapLib.HeatmapOverlay = function (opts) {\r\n        this.conf = opts;\r\n        this.conf.visible = opts.visible === undefined ? true : opts.visible;\r\n        this.heatmap = null;\r\n        this.latlngs = [];\r\n        this.bounds = null;\r\n    });\r\n    HeatmapOverlay.prototype = new BMap.Overlay();\r\n    HeatmapOverlay.prototype.initialize = function (map) {\r\n        this._map = map;\r\n        var el = document.createElement('div');\r\n        el.style.position = 'absolute';\r\n        el.style.top = 0;\r\n        el.style.left = 0;\r\n        el.style.border = 0;\r\n        el.style.width = this._map.getSize().width + 'px';\r\n        el.style.height = this._map.getSize().height + 'px';\r\n        this.conf.element = el;\r\n        if (!isSupportCanvas()) {\r\n            // 判断是否支持Canvas.\r\n            return el;\r\n        }\r\n        map.getPanes().mapPane.appendChild(el);\r\n        this.conf.valueField = this.conf.valueField || 'count';\r\n        if (typeof module !== 'undefined' && module.exports) {\r\n            this.heatmap = module.exports.create(this.conf);\r\n        }\r\n        else {\r\n            this.heatmap = h337.create(this.conf);\r\n        }\r\n        var that = this;\r\n        map.addEventListener('resize', function (e) {\r\n            var size = e.size;\r\n            el.style.width = size.width + 'px';\r\n            el.style.height = size.height + 'px';\r\n            that.heatmap._renderer.setDimensions(size.width, size.height);\r\n            that.draw();\r\n        });\r\n        this._div = el;\r\n        return el;\r\n    };\r\n    HeatmapOverlay.prototype.draw = function () {\r\n        if (!isSupportCanvas()) {\r\n            //判断是否支持Canvas.\r\n            return;\r\n        }\r\n        var currentBounds = this._map.getBounds();\r\n        if (currentBounds.equals(this.bounds)) {\r\n            return;\r\n        }\r\n        this.bounds = currentBounds;\r\n        var ne = this._map.pointToOverlayPixel(currentBounds.getNorthEast()), sw = this._map.pointToOverlayPixel(currentBounds.getSouthWest()), topY = ne.y, leftX = sw.x, h = sw.y - ne.y, w = ne.x - sw.x;\r\n        this.conf.element.style.left = leftX + 'px';\r\n        this.conf.element.style.top = topY + 'px';\r\n        this.conf.element.style.width = w + 'px';\r\n        this.conf.element.style.height = h + 'px';\r\n        //this.heatmap.store.get(\"heatmap\").resize();\r\n        if (this.latlngs.length > 0) {\r\n            this.heatmap.removeData();\r\n            var len = this.latlngs.length;\r\n            var d = {\r\n                max: this.heatmap._store.getData().max,\r\n                data: [],\r\n            };\r\n            while (len--) {\r\n                var latlng = this.latlngs[len].latlng;\r\n                if (!currentBounds.containsPoint(latlng)) {\r\n                    continue;\r\n                }\r\n                var divPixel = this._map.pointToOverlayPixel(latlng), leftX = this._map.pointToOverlayPixel(currentBounds.getSouthWest()).x, topY = this._map.pointToOverlayPixel(currentBounds.getNorthEast()).y, screenPixel = new BMap.Pixel(divPixel.x - leftX, divPixel.y - topY);\r\n                var roundedPoint = this.pixelTransform(screenPixel);\r\n                d.data.push({\r\n                    x: roundedPoint.x,\r\n                    y: roundedPoint.y,\r\n                    count: this.latlngs[len].c,\r\n                });\r\n            }\r\n            if (this.conf.radiusChangeByZoom) {\r\n                this.heatmap._store._cfgRadius = this.conf.radiusChangeByZoom(this._map.getZoom());\r\n            }\r\n            this.heatmap.setData(d);\r\n        }\r\n    };\r\n    //内部使用的坐标转化\r\n    HeatmapOverlay.prototype.pixelTransform = function (p) {\r\n        var w = this.heatmap.width, h = this.heatmap.height;\r\n        while (p.x < 0) {\r\n            p.x += w;\r\n        }\r\n        while (p.x > w) {\r\n            p.x -= w;\r\n        }\r\n        while (p.y < 0) {\r\n            p.y += h;\r\n        }\r\n        while (p.y > h) {\r\n            p.y -= h;\r\n        }\r\n        p.x = p.x >> 0;\r\n        p.y = p.y >> 0;\r\n        return p;\r\n    };\r\n    /**\r\n     * 设置热力图展现的详细数据, 实现之后,即可以立刻展现\r\n     * @param {Json Object } data\r\n     * {\"<b>max</b>\" : {Number} 权重的最大值,\r\n     * <br />\"<b>data</b>\" : {Array} 坐标详细数据,格式如下 <br/>\r\n     * {\"lng\":116.421969,\"lat\":39.913527,\"count\":3}, 其中<br/>\r\n     * lng lat分别为经纬度, count权重值\r\n     */\r\n    HeatmapOverlay.prototype.setDataSet = function (data) {\r\n        this.data = data;\r\n        if (!isSupportCanvas()) {\r\n            //判断是否支持Canvas.\r\n            return;\r\n        }\r\n        var currentBounds = this._map.getBounds();\r\n        var mapdata = {\r\n            max: data.max,\r\n            data: [],\r\n        };\r\n        var d = data.data, dlen = d.length;\r\n        this.latlngs = [];\r\n        this.heatmap.removeData();\r\n        if (this.conf.radiusChangeByZoom) {\r\n            this.heatmap._store._cfgRadius = this.conf.radiusChangeByZoom(this._map.getZoom());\r\n        }\r\n        while (dlen--) {\r\n            var latlng = new BMap.Point(d[dlen].lng, d[dlen].lat);\r\n            this.latlngs.push({\r\n                latlng: latlng,\r\n                c: d[dlen].count,\r\n            });\r\n            if (!currentBounds.containsPoint(latlng)) {\r\n                continue;\r\n            }\r\n            var divPixel = this._map.pointToOverlayPixel(latlng), leftX = this._map.pointToOverlayPixel(currentBounds.getSouthWest()).x, topY = this._map.pointToOverlayPixel(currentBounds.getNorthEast()).y, screenPixel = new BMap.Pixel(divPixel.x - leftX, divPixel.y - topY);\r\n            var point = this.pixelTransform(screenPixel);\r\n            mapdata.data.push({\r\n                x: point.x,\r\n                y: point.y,\r\n                count: d[dlen].count,\r\n            });\r\n        }\r\n        this.heatmap.setData(mapdata);\r\n    };\r\n    /**\r\n     * 添加热力图的详细坐标点\r\n     * @param {Number} lng 经度坐标\r\n     * @param {Number} lat 纬度坐标\r\n     * @param {Number} count 权重\r\n     */\r\n    HeatmapOverlay.prototype.addDataPoint = function (lng, lat, count) {\r\n        if (!isSupportCanvas()) {\r\n            return;\r\n        }\r\n        if (this.data && this.data.data) {\r\n            this.data.data.push({\r\n                lng: lng,\r\n                lat: lat,\r\n                count: count,\r\n            });\r\n        }\r\n        var latlng = new BMap.Point(lng, lat), point = this.pixelTransform(this._map.pointToOverlayPixel(latlng));\r\n        this.heatmap.store.addDataPoint(point.x, point.y, count);\r\n        this.latlngs.push({\r\n            latlng: latlng,\r\n            c: count,\r\n        });\r\n    };\r\n    /**\r\n     * 更改热力图的展现或者关闭\r\n     */\r\n    HeatmapOverlay.prototype.toggle = function () {\r\n        if (!isSupportCanvas()) {\r\n            //判断是否支持Canvas.\r\n            return;\r\n        }\r\n        if (this.conf.visible === true) {\r\n            this.conf.visible = false;\r\n        }\r\n        else {\r\n            this.conf.visible = true;\r\n        }\r\n        if (this.conf.visible) {\r\n            this.conf.element.style.display = 'block';\r\n        }\r\n        else {\r\n            this.conf.element.style.display = 'none';\r\n        }\r\n    };\r\n    /**\r\n     * 设置热力图展现的配置\r\n     * @param {Json Object} options 可选的输入参数，非必填项。可输入选项包括：<br />\r\n     * {\"<b>radius</b>\" : {String} 热力图的半径,\r\n     * <br />\"<b>visible</b>\" : {Number} 热力图是否显示,\r\n     * <br />\"<b>gradient</b>\" : {JSON} 热力图的渐变区间,\r\n     * <br />\"<b>opacity</b>\" : {Number} 热力的透明度,}\r\n     */\r\n    HeatmapOverlay.prototype.setOptions = function (options) {\r\n        if (!isSupportCanvas()) {\r\n            // 判断是否支持Canvas.\r\n            return;\r\n        }\r\n        for (var key in options) {\r\n            if (key == 'radius') {\r\n                this.heatmap._store._cfgRadius = options[key];\r\n            }\r\n            if (key == 'opacity') {\r\n                options[key] = options[key] / 100;\r\n            }\r\n        }\r\n        this.heatmap.configure(options);\r\n        if (this.data) {\r\n            this.setDataSet(this.data); // 重新渲染\r\n        }\r\n    };\r\n    function isSupportCanvas() {\r\n        var elem = document.createElement('canvas');\r\n        return !!(elem.getContext && elem.getContext('2d'));\r\n    }\r\n})();\r\n"],"names":["create","defaultRadius","HeatmapConfig","defaultRenderer","defaultGradient","0.45","0.55","0.65","0.95","1","defaultMaxOpacity","defaultMinOpacity","defaultBlur","defaultXField","defaultYField","defaultValueField","plugins","Store","prototype","_organiseData","dataPoint","forceRender","x","this","_xField","y","_yField","radi","_radi","store","_data","max","_max","min","_min","value","_valueField","radius","_cfgRadius","setDataMax","_unOrganizeData","unorganizedData","data","push","_onExtremaChange","_coordinator","emit","addData","arguments","length","dataArr","dataLen","call","organisedEntry","setData","dataPoints","pointsLen","i","_getInternalData","removeData","setDataMin","setCoordinator","coordinator","getData","config","_getColorPalette","key","gradientConfig","gradient","paletteCanvas","document","createElement","paletteCtx","getContext","width","height","createLinearGradient","addColorStop","fillStyle","fillRect","getImageData","Canvas2dRenderer","renderPartial","_drawAlpha","_colorize","renderAll","_clear","renderData","xValues","Object","keys","xValuesLen","xValue","yValues","yValuesLen","yValue","_updateGradient","_palette","updateConfig","_setStyles","setDimensions","_width","_height","canvas","shadowCanvas","shadowCtx","clearRect","ctx","_blur","blur","backgroundColor","style","_opacity","opacity","_maxOpacity","maxOpacity","_minOpacity","minOpacity","_useGradientOpacity","useGradientOpacity","blurFactor","tplCanvas","tplCtx","tpl","point","Math","rectX","rectY","_templates","beginPath","arc","PI","fill","createRadialGradient","globalAlpha","drawImage","_renderBoundaries","maxWidth","maxHeight","img","imgData","len","palette","alpha","offset","finalAlpha","putImageData","getValueAt","abs","getDataURL","toDataURL","container","element","computed","getComputedStyle","className","replace","cssText","position","appendChild","rendererFn","Coordinator","_connect","Renderer","Util","merged","argsLen","obj","Heatmap","on","evtName","callback","scope","cStore","renderer","_renderer","_store","_config","onExtremaChange","apply","configure","repaint","pluginToLoad","Error","plugin","register","pluginKey","h337","BMapLib","window","HeatmapOverlay","opts","conf","visible","undefined","heatmap","latlngs","bounds","isSupportCanvas","elem","BMap","Overlay","initialize","map","_map","that","el","top","left","border","getSize","getPanes","mapPane","valueField","module","exports","addEventListener","e","size","draw","_div","currentBounds","getBounds","equals","ne","pointToOverlayPixel","getNorthEast","sw","getSouthWest","topY","leftX","h","w","d","latlng","containsPoint","divPixel","screenPixel","Pixel","roundedPoint","pixelTransform","count","c","radiusChangeByZoom","getZoom","p","setDataSet","mapdata","dlen","Point","lng","lat","addDataPoint","toggle","display","setOptions","options"],"mappings":"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"}