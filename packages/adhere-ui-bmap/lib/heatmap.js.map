{"version":3,"file":"heatmap.js","sources":["heatmap.js"],"sourcesContent":["\"use strict\";\n/*\n * heatmap.js v2.0.0 | JavaScript Heatmap Library\n *\n * Copyright 2008-2014 Patrick Wied <heatmapjs@patrick-wied.at> - All rights reserved.\n * Dual licensed under MIT and Beerware license\n *\n * :: 2014-10-31 21:16\n */\n// (function (/*name, context,*/ factory) {\n//   // // Supports UMD. AMD, CommonJS/Node.js and browser context\n//   // if (typeof module !== 'undefined' && module.exports) {\n//   //   module.exports = factory();\n//   // } else if (typeof define === 'function' && define.amd) {\n//   //   define(factory);\n//   // } else {\n//   //   context[name] = factory();\n//   // }\n//   // context[name] = factory();\n//   // window['h337'] = factory();\n// })(\n//   /*'h337', this, */\n//     function () {\n//     // Heatmap Config stores default values and will be merged with instance config\n//     let  HeatmapConfig = {\n//       defaultRadius: 40,\n//       defaultRenderer: 'canvas2d',\n//       defaultGradient: {\n//         0.45: 'rgb(0,0,255)',\n//         0.55: 'rgb(0,255,255)',\n//         0.65: 'rgb(0,255,0)',\n//         0.95: 'yellow',\n//         1.0: 'rgb(255,0,0)',\n//       },\n//       defaultMaxOpacity: 1,\n//       defaultMinOpacity: 0,\n//       defaultBlur: 0.85,\n//       defaultXField: 'x',\n//       defaultYField: 'y',\n//       defaultValueField: 'value',\n//       plugins: {},\n//     };\n//     let  Store = (function StoreClosure() {\n//       let  Store = function Store(config) {\n//         this._coordinator = {};\n//         this._data = [];\n//         this._radi = [];\n//         this._min = 0;\n//         this._max = 1;\n//         this._xField = config['xField'] || config.defaultXField;\n//         this._yField = config['yField'] || config.defaultYField;\n//         this._valueField = config['valueField'] || config.defaultValueField;\n//\n//         if (config['radius']) {\n//           this._cfgRadius = config['radius'];\n//         }\n//       };\n//\n//       let  defaultRadius = HeatmapConfig.defaultRadius;\n//\n//       Store.prototype = {\n//         // when forceRender = false -> called from setData, omits renderall event\n//         _organiseData: function (dataPoint, forceRender) {\n//           let  x = dataPoint[this._xField];\n//           let  y = dataPoint[this._yField];\n//           let  radi = this._radi;\n//           let  store = this._data;\n//           let  max = this._max;\n//           let  min = this._min;\n//           let  value = dataPoint[this._valueField] || 1;\n//           let  radius = dataPoint.radius || this._cfgRadius || defaultRadius;\n//\n//           if (!store[x]) {\n//             store[x] = [];\n//             radi[x] = [];\n//           }\n//\n//           if (!store[x][y]) {\n//             store[x][y] = value;\n//             radi[x][y] = radius;\n//           } else {\n//             store[x][y] += value;\n//           }\n//\n//           if (store[x][y] > max) {\n//             if (!forceRender) {\n//               this._max = store[x][y];\n//             } else {\n//               this.setDataMax(store[x][y]);\n//             }\n//             return false;\n//           } else {\n//             return {\n//               x: x,\n//               y: y,\n//               value: value,\n//               radius: radius,\n//               min: min,\n//               max: max,\n//             };\n//           }\n//         },\n//         _unOrganizeData: function () {\n//           let  unorganizedData = [];\n//           let  data = this._data;\n//           let  radi = this._radi;\n//\n//           for (let  x in data) {\n//             for (let  y in data[x]) {\n//               unorganizedData.push({\n//                 x: x,\n//                 y: y,\n//                 radius: radi[x][y],\n//                 value: data[x][y],\n//               });\n//             }\n//           }\n//           return {\n//             min: this._min,\n//             max: this._max,\n//             data: unorganizedData,\n//           };\n//         },\n//         _onExtremaChange: function () {\n//           this._coordinator.emit('extremachange', {\n//             min: this._min,\n//             max: this._max,\n//           });\n//         },\n//         addData: function () {\n//           if (arguments[0].length > 0) {\n//             let  dataArr = arguments[0];\n//             let  dataLen = dataArr.length;\n//             while (dataLen--) {\n//               this.addData.call(this, dataArr[dataLen]);\n//             }\n//           } else {\n//             // add to store\n//             let  organisedEntry = this._organiseData(arguments[0], true);\n//             if (organisedEntry) {\n//               this._coordinator.emit('renderpartial', {\n//                 min: this._min,\n//                 max: this._max,\n//                 data: [organisedEntry],\n//               });\n//             }\n//           }\n//           return this;\n//         },\n//         setData: function (data) {\n//           let  dataPoints = data.data;\n//           let  pointsLen = dataPoints.length;\n//\n//           // reset data arrays\n//           this._data = [];\n//           this._radi = [];\n//\n//           for (let  i = 0; i < pointsLen; i++) {\n//             this._organiseData(dataPoints[i], false);\n//           }\n//           this._max = data.max;\n//           this._min = data.min || 0;\n//\n//           this._onExtremaChange();\n//           this._coordinator.emit('renderall', this._getInternalData());\n//           return this;\n//         },\n//         removeData: function () {\n//           // TODO: implement\n//         },\n//         setDataMax: function (max) {\n//           this._max = max;\n//           this._onExtremaChange();\n//           this._coordinator.emit('renderall', this._getInternalData());\n//           return this;\n//         },\n//         setDataMin: function (min) {\n//           this._min = min;\n//           this._onExtremaChange();\n//           this._coordinator.emit('renderall', this._getInternalData());\n//           return this;\n//         },\n//         setCoordinator: function (coordinator) {\n//           this._coordinator = coordinator;\n//         },\n//         _getInternalData: function () {\n//           return {\n//             max: this._max,\n//             min: this._min,\n//             data: this._data,\n//             radi: this._radi,\n//           };\n//         },\n//         getData: function () {\n//           return this._unOrganizeData();\n//         } /*,\n//\n//       TODO: rethink.\n//\n//     getValueAt: function(point) {\n//       let  value;\n//       let  radius = 100;\n//       let  x = point.x;\n//       let  y = point.y;\n//       let  data = this._data;\n//\n//       if (data[x] && data[x][y]) {\n//         return data[x][y];\n//       } else {\n//         let  values = [];\n//         // radial search for datapoints based on default radius\n//         for(let  distance = 1; distance < radius; distance++) {\n//           let  neighbors = distance * 2 +1;\n//           let  startX = x - distance;\n//           let  startY = y - distance;\n//\n//           for(let  i = 0; i < neighbors; i++) {\n//             for (let  o = 0; o < neighbors; o++) {\n//               if ((i == 0 || i == neighbors-1) || (o == 0 || o == neighbors-1)) {\n//                 if (data[startY+i] && data[startY+i][startX+o]) {\n//                   values.push(data[startY+i][startX+o]);\n//                 }\n//               } else {\n//                 continue;\n//               }\n//             }\n//           }\n//         }\n//         if (values.length > 0) {\n//           return Math.max.apply(Math, values);\n//         }\n//       }\n//       return false;\n//     }*/,\n//       };\n//\n//       return Store;\n//     })();\n//\n//     let  Canvas2dRenderer = (function Canvas2dRendererClosure() {\n//       let  _getColorPalette = function (config) {\n//         let  gradientConfig = config.gradient || config.defaultGradient;\n//         let  paletteCanvas = document.createElement('canvas');\n//         let  paletteCtx = paletteCanvas.getContext('2d');\n//\n//         paletteCanvas.width = 256;\n//         paletteCanvas.height = 1;\n//\n//         let  gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);\n//         for (let  key in gradientConfig) {\n//           gradient.addColorStop(key, gradientConfig[key]);\n//         }\n//\n//         paletteCtx.fillStyle = gradient;\n//         paletteCtx.fillRect(0, 0, 256, 1);\n//\n//         return paletteCtx.getImageData(0, 0, 256, 1).data;\n//       };\n//\n//       let  _getPointTemplate = function (radius, blurFactor) {\n//         let  tplCanvas = document.createElement('canvas');\n//         let  tplCtx = tplCanvas.getContext('2d');\n//         let  x = radius;\n//         let  y = radius;\n//         tplCanvas.width = tplCanvas.height = radius * 2;\n//\n//         if (blurFactor == 1) {\n//           tplCtx.beginPath();\n//           tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);\n//           tplCtx.fillStyle = 'rgba(0,0,0,1)';\n//           tplCtx.fill();\n//         } else {\n//           let  gradient = tplCtx.createRadialGradient(x, y, radius * blurFactor, x, y, radius);\n//           gradient.addColorStop(0, 'rgba(0,0,0,1)');\n//           gradient.addColorStop(1, 'rgba(0,0,0,0)');\n//           tplCtx.fillStyle = gradient;\n//           tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);\n//         }\n//\n//         return tplCanvas;\n//       };\n//\n//       let  _prepareData = function (data) {\n//         let  renderData = [];\n//         let  min = data.min;\n//         let  max = data.max;\n//         let  radi = data.radi;\n//         let  data = data.data;\n//\n//         let  xValues = Object.keys(data);\n//         let  xValuesLen = xValues.length;\n//\n//         while (xValuesLen--) {\n//           let  xValue = xValues[xValuesLen];\n//           let  yValues = Object.keys(data[xValue]);\n//           let  yValuesLen = yValues.length;\n//           while (yValuesLen--) {\n//             let  yValue = yValues[yValuesLen];\n//             let  value = data[xValue][yValue];\n//             let  radius = radi[xValue][yValue];\n//             renderData.push({\n//               x: xValue,\n//               y: yValue,\n//               value: value,\n//               radius: radius,\n//             });\n//           }\n//         }\n//\n//         return {\n//           min: min,\n//           max: max,\n//           data: renderData,\n//         };\n//       };\n//\n//       function Canvas2dRenderer(config) {\n//         let  container = config.element;\n//         let  shadowCanvas = (this.shadowCanvas = document.createElement('canvas'));\n//         let  canvas = (this.canvas = config.canvas || document.createElement('canvas'));\n//         let  renderBoundaries = (this._renderBoundaries = [10000, 10000, 0, 0]);\n//\n//         let  computed = getComputedStyle(config.element) || {};\n//\n//         canvas.className = 'heatmap-canvas';\n//\n//         this._width = canvas.width = shadowCanvas.width = +computed.width.replace(/px/, '');\n//         this._height = canvas.height = shadowCanvas.height = +computed.height.replace(/px/, '');\n//\n//         this.shadowCtx = shadowCanvas.getContext('2d');\n//         this.ctx = canvas.getContext('2d');\n//\n//         // @TODO:\n//         // conditional wrapper\n//\n//         canvas.style.cssText = shadowCanvas.style.cssText = 'position:absolute;left:0;top:0;';\n//\n//         container.style.position = 'relative';\n//         container.appendChild(canvas);\n//\n//         this._palette = _getColorPalette(config);\n//         this._templates = {};\n//\n//         this._setStyles(config);\n//       }\n//\n//       Canvas2dRenderer.prototype = {\n//         renderPartial: function (data) {\n//           this._drawAlpha(data);\n//           this._colorize();\n//         },\n//         renderAll: function (data) {\n//           // reset render boundaries\n//           this._clear();\n//           this._drawAlpha(_prepareData(data));\n//           this._colorize();\n//         },\n//         _updateGradient: function (config) {\n//           this._palette = _getColorPalette(config);\n//         },\n//         updateConfig: function (config) {\n//           if (config['gradient']) {\n//             this._updateGradient(config);\n//           }\n//           this._setStyles(config);\n//         },\n//         setDimensions: function (width, height) {\n//           this._width = width;\n//           this._height = height;\n//           this.canvas.width = this.shadowCanvas.width = width;\n//           this.canvas.height = this.shadowCanvas.height = height;\n//         },\n//         _clear: function () {\n//           this.shadowCtx.clearRect(0, 0, this._width, this._height);\n//           this.ctx.clearRect(0, 0, this._width, this._height);\n//         },\n//         _setStyles: function (config) {\n//           this._blur = config.blur == 0 ? 0 : config.blur || config.defaultBlur;\n//\n//           if (config.backgroundColor) {\n//             this.canvas.style.backgroundColor = config.backgroundColor;\n//           }\n//\n//           this._opacity = (config.opacity || 0) * 255;\n//           this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255;\n//           this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255;\n//           this._useGradientOpacity = !!config.useGradientOpacity;\n//         },\n//         _drawAlpha: function (data) {\n//           let  min = (this._min = data.min);\n//           let  max = (this._max = data.max);\n//           let  data = data.data || [];\n//           let  dataLen = data.length;\n//           // on a point basis?\n//           let  blur = 1 - this._blur;\n//\n//           while (dataLen--) {\n//             let  point = data[dataLen];\n//\n//             let  x = point.x;\n//             let  y = point.y;\n//             let  radius = point.radius;\n//             // if value is bigger than max\n//             // use max as value\n//             let  value = Math.min(point.value, max);\n//             let  rectX = x - radius;\n//             let  rectY = y - radius;\n//             let  shadowCtx = this.shadowCtx;\n//\n//             let  tpl;\n//             if (!this._templates[radius]) {\n//               this._templates[radius] = tpl = _getPointTemplate(radius, blur);\n//             } else {\n//               tpl = this._templates[radius];\n//             }\n//             // value from minimum / value range\n//             // => [0, 1]\n//             shadowCtx.globalAlpha = (value - min) / (max - min);\n//\n//             shadowCtx.drawImage(tpl, rectX, rectY);\n//\n//             // update renderBoundaries\n//             if (rectX < this._renderBoundaries[0]) {\n//               this._renderBoundaries[0] = rectX;\n//             }\n//             if (rectY < this._renderBoundaries[1]) {\n//               this._renderBoundaries[1] = rectY;\n//             }\n//             if (rectX + 2 * radius > this._renderBoundaries[2]) {\n//               this._renderBoundaries[2] = rectX + 2 * radius;\n//             }\n//             if (rectY + 2 * radius > this._renderBoundaries[3]) {\n//               this._renderBoundaries[3] = rectY + 2 * radius;\n//             }\n//           }\n//         },\n//         _colorize: function () {\n//           let  x = this._renderBoundaries[0];\n//           let  y = this._renderBoundaries[1];\n//           let  width = this._renderBoundaries[2] - x;\n//           let  height = this._renderBoundaries[3] - y;\n//           let  maxWidth = this._width;\n//           let  maxHeight = this._height;\n//           let  opacity = this._opacity;\n//           let  maxOpacity = this._maxOpacity;\n//           let  minOpacity = this._minOpacity;\n//           let  useGradientOpacity = this._useGradientOpacity;\n//\n//           if (x < 0) {\n//             x = 0;\n//           }\n//           if (y < 0) {\n//             y = 0;\n//           }\n//           if (x + width > maxWidth) {\n//             width = maxWidth - x;\n//           }\n//           if (y + height > maxHeight) {\n//             height = maxHeight - y;\n//           }\n//\n//           let  img = this.shadowCtx.getImageData(x, y, width, height);\n//           let  imgData = img.data;\n//           let  len = imgData.length;\n//           let  palette = this._palette;\n//\n//           for (let  i = 3; i < len; i += 4) {\n//             let  alpha = imgData[i];\n//             let  offset = alpha * 4;\n//\n//             if (!offset) {\n//               continue;\n//             }\n//\n//             let  finalAlpha;\n//             if (opacity > 0) {\n//               finalAlpha = opacity;\n//             } else {\n//               if (alpha < maxOpacity) {\n//                 if (alpha < minOpacity) {\n//                   finalAlpha = minOpacity;\n//                 } else {\n//                   finalAlpha = alpha;\n//                 }\n//               } else {\n//                 finalAlpha = maxOpacity;\n//               }\n//             }\n//\n//             imgData[i - 3] = palette[offset];\n//             imgData[i - 2] = palette[offset + 1];\n//             imgData[i - 1] = palette[offset + 2];\n//             imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;\n//           }\n//\n//           img.data = imgData;\n//           this.ctx.putImageData(img, x, y);\n//\n//           this._renderBoundaries = [1000, 1000, 0, 0];\n//         },\n//         getValueAt: function (point) {\n//           let  value;\n//           let  shadowCtx = this.shadowCtx;\n//           let  img = shadowCtx.getImageData(point.x, point.y, 1, 1);\n//           let  data = img.data[3];\n//           let  max = this._max;\n//           let  min = this._min;\n//\n//           value = (Math.abs(max - min) * (data / 255)) >> 0;\n//\n//           return value;\n//         },\n//         getDataURL: function () {\n//           return this.canvas.toDataURL();\n//         },\n//       };\n//\n//       return Canvas2dRenderer;\n//     })();\n//\n//     let  Renderer = (function RendererClosure() {\n//       let  rendererFn = false;\n//\n//       if (HeatmapConfig['defaultRenderer'] === 'canvas2d') {\n//         rendererFn = Canvas2dRenderer;\n//       }\n//\n//       return rendererFn;\n//     })();\n//\n//     let  Util = {\n//       merge: function () {\n//         let  merged = {};\n//         let  argsLen = arguments.length;\n//         for (let  i = 0; i < argsLen; i++) {\n//           let  obj = arguments[i];\n//           for (let  key in obj) {\n//             merged[key] = obj[key];\n//           }\n//         }\n//         return merged;\n//       },\n//     };\n//     // Heatmap Constructor\n//     let  Heatmap = (function HeatmapClosure() {\n//       let  Coordinator = (function CoordinatorClosure() {\n//         function Coordinator() {\n//           this.cStore = {};\n//         }\n//\n//         Coordinator.prototype = {\n//           on: function (evtName, callback, scope) {\n//             let  cStore = this.cStore;\n//\n//             if (!cStore[evtName]) {\n//               cStore[evtName] = [];\n//             }\n//             cStore[evtName].push(function (data) {\n//               return callback.call(scope, data);\n//             });\n//           },\n//           emit: function (evtName, data) {\n//             let  cStore = this.cStore;\n//             if (cStore[evtName]) {\n//               let  len = cStore[evtName].length;\n//               for (let  i = 0; i < len; i++) {\n//                 let  callback = cStore[evtName][i];\n//                 callback(data);\n//               }\n//             }\n//           },\n//         };\n//\n//         return Coordinator;\n//       })();\n//\n//       let  _connect = function (scope) {\n//         let  renderer = scope._renderer;\n//         let  coordinator = scope._coordinator;\n//         let  store = scope._store;\n//\n//         coordinator.on('renderpartial', renderer.renderPartial, renderer);\n//         coordinator.on('renderall', renderer.renderAll, renderer);\n//         coordinator.on('extremachange', function (data) {\n//           scope._config.onExtremaChange &&\n//             scope._config.onExtremaChange({\n//               min: data.min,\n//               max: data.max,\n//               gradient: scope._config['gradient'] || scope._config['defaultGradient'],\n//             });\n//         });\n//         store.setCoordinator(coordinator);\n//       };\n//\n//       function Heatmap() {\n//         let  config = (this._config = Util.merge(HeatmapConfig, arguments[0] || {}));\n//         this._coordinator = new Coordinator();\n//         if (config['plugin']) {\n//           let  pluginToLoad = config['plugin'];\n//           if (!HeatmapConfig.plugins[pluginToLoad]) {\n//             throw new Error(\n//               \"Plugin '\" + pluginToLoad + \"' not found. Maybe it was not registered.\",\n//             );\n//           } else {\n//             let  plugin = HeatmapConfig.plugins[pluginToLoad];\n//             // set plugin renderer and store\n//             this._renderer = new plugin.renderer(config);\n//             this._store = new plugin.store(config);\n//           }\n//         } else {\n//           this._renderer = new Renderer(config);\n//           this._store = new Store(config);\n//         }\n//         _connect(this);\n//       }\n//\n//       // @TODO:\n//       // add API documentation\n//       Heatmap.prototype = {\n//         addData: function () {\n//           this._store.addData.apply(this._store, arguments);\n//           return this;\n//         },\n//         removeData: function () {\n//           this._store.removeData && this._store.removeData.apply(this._store, arguments);\n//           return this;\n//         },\n//         setData: function () {\n//           this._store.setData.apply(this._store, arguments);\n//           return this;\n//         },\n//         setDataMax: function () {\n//           this._store.setDataMax.apply(this._store, arguments);\n//           return this;\n//         },\n//         setDataMin: function () {\n//           this._store.setDataMin.apply(this._store, arguments);\n//           return this;\n//         },\n//         configure: function (config) {\n//           this._config = Util.merge(this._config, config);\n//           this._renderer.updateConfig(this._config);\n//           this._coordinator.emit('renderall', this._store._getInternalData());\n//           return this;\n//         },\n//         repaint: function () {\n//           this._coordinator.emit('renderall', this._store._getInternalData());\n//           return this;\n//         },\n//         getData: function () {\n//           return this._store.getData();\n//         },\n//         getDataURL: function () {\n//           return this._renderer.getDataURL();\n//         },\n//         getValueAt: function (point) {\n//           if (this._store.getValueAt) {\n//             return this._store.getValueAt(point);\n//           } else if (this._renderer.getValueAt) {\n//             return this._renderer.getValueAt(point);\n//           } else {\n//             return null;\n//           }\n//         },\n//       };\n//\n//       return Heatmap;\n//     })();\n//\n//     // core\n//     let  heatmapFactory = {\n//       create: function (config) {\n//         return new Heatmap(config);\n//       },\n//       register: function (pluginKey, plugin) {\n//         HeatmapConfig.plugins[pluginKey] = plugin;\n//       },\n//     };\n//\n//     return heatmapFactory;\n//   },\n// );\n/*==============================以上部分为heatmap.js的核心代码,只负责热力图的展现====================================*/\n/*==============================以下部分为专为百度地图打造的覆盖物===================================================*/\n/**\n * @fileoverview 百度地图的热力图功能,对外开放。\n * 主要基于http://www.patrick-wied.at/static/heatmapjs/index.html 修改而得\n\n * 主入口类是<a href=\"symbols/BMapLib.Heatmap.html\">Heatmap</a>，\n * 基于Baidu Map API 2.0。\n *\n * @author Baidu Map Api Group\n * @version 1.0\n */\nfunction create() {\n    // Heatmap Config stores default values and will be merged with instance config\n    var HeatmapConfig = {\n        defaultRadius: 40,\n        defaultRenderer: 'canvas2d',\n        defaultGradient: {\n            0.45: 'rgb(0,0,255)',\n            0.55: 'rgb(0,255,255)',\n            0.65: 'rgb(0,255,0)',\n            0.95: 'yellow',\n            1.0: 'rgb(255,0,0)',\n        },\n        defaultMaxOpacity: 1,\n        defaultMinOpacity: 0,\n        defaultBlur: 0.85,\n        defaultXField: 'x',\n        defaultYField: 'y',\n        defaultValueField: 'value',\n        plugins: {},\n    };\n    var Store = (function StoreClosure() {\n        var Store = function Store(config) {\n            this._coordinator = {};\n            this._data = [];\n            this._radi = [];\n            this._min = 0;\n            this._max = 1;\n            this._xField = config['xField'] || config.defaultXField;\n            this._yField = config['yField'] || config.defaultYField;\n            this._valueField = config['valueField'] || config.defaultValueField;\n            if (config['radius']) {\n                this._cfgRadius = config['radius'];\n            }\n        };\n        var defaultRadius = HeatmapConfig.defaultRadius;\n        Store.prototype = {\n            // when forceRender = false -> called from setData, omits renderall event\n            _organiseData: function (dataPoint, forceRender) {\n                var x = dataPoint[this._xField];\n                var y = dataPoint[this._yField];\n                var radi = this._radi;\n                var store = this._data;\n                var max = this._max;\n                var min = this._min;\n                var value = dataPoint[this._valueField] || 1;\n                var radius = dataPoint.radius || this._cfgRadius || defaultRadius;\n                if (!store[x]) {\n                    store[x] = [];\n                    radi[x] = [];\n                }\n                if (!store[x][y]) {\n                    store[x][y] = value;\n                    radi[x][y] = radius;\n                }\n                else {\n                    store[x][y] += value;\n                }\n                if (store[x][y] > max) {\n                    if (!forceRender) {\n                        this._max = store[x][y];\n                    }\n                    else {\n                        this.setDataMax(store[x][y]);\n                    }\n                    return false;\n                }\n                else {\n                    return {\n                        x: x,\n                        y: y,\n                        value: value,\n                        radius: radius,\n                        min: min,\n                        max: max,\n                    };\n                }\n            },\n            _unOrganizeData: function () {\n                var unorganizedData = [];\n                var data = this._data;\n                var radi = this._radi;\n                for (var x in data) {\n                    for (var y in data[x]) {\n                        unorganizedData.push({\n                            x: x,\n                            y: y,\n                            radius: radi[x][y],\n                            value: data[x][y],\n                        });\n                    }\n                }\n                return {\n                    min: this._min,\n                    max: this._max,\n                    data: unorganizedData,\n                };\n            },\n            _onExtremaChange: function () {\n                this._coordinator.emit('extremachange', {\n                    min: this._min,\n                    max: this._max,\n                });\n            },\n            addData: function () {\n                if (arguments[0].length > 0) {\n                    var dataArr = arguments[0];\n                    var dataLen = dataArr.length;\n                    while (dataLen--) {\n                        this.addData.call(this, dataArr[dataLen]);\n                    }\n                }\n                else {\n                    // add to store\n                    var organisedEntry = this._organiseData(arguments[0], true);\n                    if (organisedEntry) {\n                        this._coordinator.emit('renderpartial', {\n                            min: this._min,\n                            max: this._max,\n                            data: [organisedEntry],\n                        });\n                    }\n                }\n                return this;\n            },\n            setData: function (data) {\n                var dataPoints = data.data;\n                var pointsLen = dataPoints.length;\n                // reset data arrays\n                this._data = [];\n                this._radi = [];\n                for (var i = 0; i < pointsLen; i++) {\n                    this._organiseData(dataPoints[i], false);\n                }\n                this._max = data.max;\n                this._min = data.min || 0;\n                this._onExtremaChange();\n                this._coordinator.emit('renderall', this._getInternalData());\n                return this;\n            },\n            removeData: function () {\n                // TODO: implement\n            },\n            setDataMax: function (max) {\n                this._max = max;\n                this._onExtremaChange();\n                this._coordinator.emit('renderall', this._getInternalData());\n                return this;\n            },\n            setDataMin: function (min) {\n                this._min = min;\n                this._onExtremaChange();\n                this._coordinator.emit('renderall', this._getInternalData());\n                return this;\n            },\n            setCoordinator: function (coordinator) {\n                this._coordinator = coordinator;\n            },\n            _getInternalData: function () {\n                return {\n                    max: this._max,\n                    min: this._min,\n                    data: this._data,\n                    radi: this._radi,\n                };\n            },\n            getData: function () {\n                return this._unOrganizeData();\n            } /*,\n      \n            TODO: rethink.\n      \n          getValueAt: function(point) {\n            var   value;\n            var   radius = 100;\n            var   x = point.x;\n            var   y = point.y;\n            var   data = this._data;\n      \n            if (data[x] && data[x][y]) {\n              return data[x][y];\n            } else {\n              var   values = [];\n              // radial search for datapoints based on default radius\n              for(var   distance = 1; distance < radius; distance++) {\n                var   neighbors = distance * 2 +1;\n                var   startX = x - distance;\n                var   startY = y - distance;\n      \n                for(var   i = 0; i < neighbors; i++) {\n                  for (var   o = 0; o < neighbors; o++) {\n                    if ((i == 0 || i == neighbors-1) || (o == 0 || o == neighbors-1)) {\n                      if (data[startY+i] && data[startY+i][startX+o]) {\n                        values.push(data[startY+i][startX+o]);\n                      }\n                    } else {\n                      continue;\n                    }\n                  }\n                }\n              }\n              if (values.length > 0) {\n                return Math.max.apply(Math, values);\n              }\n            }\n            return false;\n          }*/,\n        };\n        return Store;\n    })();\n    var Canvas2dRenderer = (function Canvas2dRendererClosure() {\n        var _getColorPalette = function (config) {\n            var gradientConfig = config.gradient || config.defaultGradient;\n            var paletteCanvas = document.createElement('canvas');\n            var paletteCtx = paletteCanvas.getContext('2d');\n            paletteCanvas.width = 256;\n            paletteCanvas.height = 1;\n            var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);\n            for (var key in gradientConfig) {\n                gradient.addColorStop(key, gradientConfig[key]);\n            }\n            paletteCtx.fillStyle = gradient;\n            paletteCtx.fillRect(0, 0, 256, 1);\n            return paletteCtx.getImageData(0, 0, 256, 1).data;\n        };\n        var _getPointTemplate = function (radius, blurFactor) {\n            var tplCanvas = document.createElement('canvas');\n            var tplCtx = tplCanvas.getContext('2d');\n            var x = radius;\n            var y = radius;\n            tplCanvas.width = tplCanvas.height = radius * 2;\n            if (blurFactor == 1) {\n                tplCtx.beginPath();\n                tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);\n                tplCtx.fillStyle = 'rgba(0,0,0,1)';\n                tplCtx.fill();\n            }\n            else {\n                var gradient = tplCtx.createRadialGradient(x, y, radius * blurFactor, x, y, radius);\n                gradient.addColorStop(0, 'rgba(0,0,0,1)');\n                gradient.addColorStop(1, 'rgba(0,0,0,0)');\n                tplCtx.fillStyle = gradient;\n                tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);\n            }\n            return tplCanvas;\n        };\n        var _prepareData = function (data) {\n            var renderData = [];\n            var min = data.min;\n            var max = data.max;\n            var radi = data.radi;\n            var data = data.data;\n            var xValues = Object.keys(data);\n            var xValuesLen = xValues.length;\n            while (xValuesLen--) {\n                var xValue = xValues[xValuesLen];\n                var yValues = Object.keys(data[xValue]);\n                var yValuesLen = yValues.length;\n                while (yValuesLen--) {\n                    var yValue = yValues[yValuesLen];\n                    var value = data[xValue][yValue];\n                    var radius = radi[xValue][yValue];\n                    renderData.push({\n                        x: xValue,\n                        y: yValue,\n                        value: value,\n                        radius: radius,\n                    });\n                }\n            }\n            return {\n                min: min,\n                max: max,\n                data: renderData,\n            };\n        };\n        function Canvas2dRenderer(config) {\n            var container = config.element;\n            var shadowCanvas = (this.shadowCanvas = document.createElement('canvas'));\n            var canvas = (this.canvas = config.canvas || document.createElement('canvas'));\n            var renderBoundaries = (this._renderBoundaries = [10000, 10000, 0, 0]);\n            var computed = getComputedStyle(config.element) || {};\n            canvas.className = 'heatmap-canvas';\n            this._width = canvas.width = shadowCanvas.width = +computed.width.replace(/px/, '');\n            this._height = canvas.height = shadowCanvas.height = +computed.height.replace(/px/, '');\n            this.shadowCtx = shadowCanvas.getContext('2d');\n            this.ctx = canvas.getContext('2d');\n            // @TODO:\n            // conditional wrapper\n            canvas.style.cssText = shadowCanvas.style.cssText = 'position:absolute;left:0;top:0;';\n            container.style.position = 'relative';\n            container.appendChild(canvas);\n            this._palette = _getColorPalette(config);\n            this._templates = {};\n            this._setStyles(config);\n        }\n        Canvas2dRenderer.prototype = {\n            renderPartial: function (data) {\n                this._drawAlpha(data);\n                this._colorize();\n            },\n            renderAll: function (data) {\n                // reset render boundaries\n                this._clear();\n                this._drawAlpha(_prepareData(data));\n                this._colorize();\n            },\n            _updateGradient: function (config) {\n                this._palette = _getColorPalette(config);\n            },\n            updateConfig: function (config) {\n                if (config['gradient']) {\n                    this._updateGradient(config);\n                }\n                this._setStyles(config);\n            },\n            setDimensions: function (width, height) {\n                this._width = width;\n                this._height = height;\n                this.canvas.width = this.shadowCanvas.width = width;\n                this.canvas.height = this.shadowCanvas.height = height;\n            },\n            _clear: function () {\n                this.shadowCtx.clearRect(0, 0, this._width, this._height);\n                this.ctx.clearRect(0, 0, this._width, this._height);\n            },\n            _setStyles: function (config) {\n                this._blur = config.blur == 0 ? 0 : config.blur || config.defaultBlur;\n                if (config.backgroundColor) {\n                    this.canvas.style.backgroundColor = config.backgroundColor;\n                }\n                this._opacity = (config.opacity || 0) * 255;\n                this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255;\n                this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255;\n                this._useGradientOpacity = !!config.useGradientOpacity;\n            },\n            _drawAlpha: function (data) {\n                var min = (this._min = data.min);\n                var max = (this._max = data.max);\n                var data = data.data || [];\n                var dataLen = data.length;\n                // on a point basis?\n                var blur = 1 - this._blur;\n                while (dataLen--) {\n                    var point = data[dataLen];\n                    var x = point.x;\n                    var y = point.y;\n                    var radius = point.radius;\n                    // if value is bigger than max\n                    // use max as value\n                    var value = Math.min(point.value, max);\n                    var rectX = x - radius;\n                    var rectY = y - radius;\n                    var shadowCtx = this.shadowCtx;\n                    var tpl;\n                    if (!this._templates[radius]) {\n                        this._templates[radius] = tpl = _getPointTemplate(radius, blur);\n                    }\n                    else {\n                        tpl = this._templates[radius];\n                    }\n                    // value from minimum / value range\n                    // => [0, 1]\n                    shadowCtx.globalAlpha = (value - min) / (max - min);\n                    shadowCtx.drawImage(tpl, rectX, rectY);\n                    // update renderBoundaries\n                    if (rectX < this._renderBoundaries[0]) {\n                        this._renderBoundaries[0] = rectX;\n                    }\n                    if (rectY < this._renderBoundaries[1]) {\n                        this._renderBoundaries[1] = rectY;\n                    }\n                    if (rectX + 2 * radius > this._renderBoundaries[2]) {\n                        this._renderBoundaries[2] = rectX + 2 * radius;\n                    }\n                    if (rectY + 2 * radius > this._renderBoundaries[3]) {\n                        this._renderBoundaries[3] = rectY + 2 * radius;\n                    }\n                }\n            },\n            _colorize: function () {\n                var x = this._renderBoundaries[0];\n                var y = this._renderBoundaries[1];\n                var width = this._renderBoundaries[2] - x;\n                var height = this._renderBoundaries[3] - y;\n                var maxWidth = this._width;\n                var maxHeight = this._height;\n                var opacity = this._opacity;\n                var maxOpacity = this._maxOpacity;\n                var minOpacity = this._minOpacity;\n                var useGradientOpacity = this._useGradientOpacity;\n                if (x < 0) {\n                    x = 0;\n                }\n                if (y < 0) {\n                    y = 0;\n                }\n                if (x + width > maxWidth) {\n                    width = maxWidth - x;\n                }\n                if (y + height > maxHeight) {\n                    height = maxHeight - y;\n                }\n                var img = this.shadowCtx.getImageData(x, y, width, height);\n                var imgData = img.data;\n                var len = imgData.length;\n                var palette = this._palette;\n                for (var i = 3; i < len; i += 4) {\n                    var alpha = imgData[i];\n                    var offset = alpha * 4;\n                    if (!offset) {\n                        continue;\n                    }\n                    var finalAlpha;\n                    if (opacity > 0) {\n                        finalAlpha = opacity;\n                    }\n                    else {\n                        if (alpha < maxOpacity) {\n                            if (alpha < minOpacity) {\n                                finalAlpha = minOpacity;\n                            }\n                            else {\n                                finalAlpha = alpha;\n                            }\n                        }\n                        else {\n                            finalAlpha = maxOpacity;\n                        }\n                    }\n                    imgData[i - 3] = palette[offset];\n                    imgData[i - 2] = palette[offset + 1];\n                    imgData[i - 1] = palette[offset + 2];\n                    imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;\n                }\n                // img.data = imgData;\n                this.ctx.putImageData(img, x, y);\n                this._renderBoundaries = [1000, 1000, 0, 0];\n            },\n            getValueAt: function (point) {\n                var value;\n                var shadowCtx = this.shadowCtx;\n                var img = shadowCtx.getImageData(point.x, point.y, 1, 1);\n                var data = img.data[3];\n                var max = this._max;\n                var min = this._min;\n                value = (Math.abs(max - min) * (data / 255)) >> 0;\n                return value;\n            },\n            getDataURL: function () {\n                return this.canvas.toDataURL();\n            },\n        };\n        return Canvas2dRenderer;\n    })();\n    var Renderer = (function RendererClosure() {\n        var rendererFn = false;\n        if (HeatmapConfig['defaultRenderer'] === 'canvas2d') {\n            rendererFn = Canvas2dRenderer;\n        }\n        return rendererFn;\n    })();\n    var Util = {\n        merge: function () {\n            var merged = {};\n            var argsLen = arguments.length;\n            for (var i = 0; i < argsLen; i++) {\n                var obj = arguments[i];\n                for (var key in obj) {\n                    merged[key] = obj[key];\n                }\n            }\n            return merged;\n        },\n    };\n    // Heatmap Constructor\n    var Heatmap = (function HeatmapClosure() {\n        var Coordinator = (function CoordinatorClosure() {\n            function Coordinator() {\n                this.cStore = {};\n            }\n            Coordinator.prototype = {\n                on: function (evtName, callback, scope) {\n                    var cStore = this.cStore;\n                    if (!cStore[evtName]) {\n                        cStore[evtName] = [];\n                    }\n                    cStore[evtName].push(function (data) {\n                        return callback.call(scope, data);\n                    });\n                },\n                emit: function (evtName, data) {\n                    var cStore = this.cStore;\n                    if (cStore[evtName]) {\n                        var len = cStore[evtName].length;\n                        for (var i = 0; i < len; i++) {\n                            var callback = cStore[evtName][i];\n                            callback(data);\n                        }\n                    }\n                },\n            };\n            return Coordinator;\n        })();\n        var _connect = function (scope) {\n            var renderer = scope._renderer;\n            var coordinator = scope._coordinator;\n            var store = scope._store;\n            coordinator.on('renderpartial', renderer.renderPartial, renderer);\n            coordinator.on('renderall', renderer.renderAll, renderer);\n            coordinator.on('extremachange', function (data) {\n                scope._config.onExtremaChange &&\n                    scope._config.onExtremaChange({\n                        min: data.min,\n                        max: data.max,\n                        gradient: scope._config['gradient'] || scope._config['defaultGradient'],\n                    });\n            });\n            store.setCoordinator(coordinator);\n        };\n        function Heatmap() {\n            var config = (this._config = Util.merge(HeatmapConfig, arguments[0] || {}));\n            this._coordinator = new Coordinator();\n            if (config['plugin']) {\n                var pluginToLoad = config['plugin'];\n                if (!HeatmapConfig.plugins[pluginToLoad]) {\n                    throw new Error(\"Plugin '\" + pluginToLoad + \"' not found. Maybe it was not registered.\");\n                }\n                else {\n                    var plugin = HeatmapConfig.plugins[pluginToLoad];\n                    // set plugin renderer and store\n                    this._renderer = new plugin.renderer(config);\n                    this._store = new plugin.store(config);\n                }\n            }\n            else {\n                this._renderer = new Renderer(config);\n                this._store = new Store(config);\n            }\n            _connect(this);\n        }\n        // @TODO:\n        // add API documentation\n        Heatmap.prototype = {\n            addData: function () {\n                this._store.addData.apply(this._store, arguments);\n                return this;\n            },\n            removeData: function () {\n                this._store.removeData && this._store.removeData.apply(this._store, arguments);\n                return this;\n            },\n            setData: function () {\n                this._store.setData.apply(this._store, arguments);\n                return this;\n            },\n            setDataMax: function () {\n                this._store.setDataMax.apply(this._store, arguments);\n                return this;\n            },\n            setDataMin: function () {\n                this._store.setDataMin.apply(this._store, arguments);\n                return this;\n            },\n            configure: function (config) {\n                this._config = Util.merge(this._config, config);\n                this._renderer.updateConfig(this._config);\n                this._coordinator.emit('renderall', this._store._getInternalData());\n                return this;\n            },\n            repaint: function () {\n                this._coordinator.emit('renderall', this._store._getInternalData());\n                return this;\n            },\n            getData: function () {\n                return this._store.getData();\n            },\n            getDataURL: function () {\n                return this._renderer.getDataURL();\n            },\n            getValueAt: function (point) {\n                if (this._store.getValueAt) {\n                    return this._store.getValueAt(point);\n                }\n                else if (this._renderer.getValueAt) {\n                    return this._renderer.getValueAt(point);\n                }\n                else {\n                    return null;\n                }\n            },\n        };\n        return Heatmap;\n    })();\n    // core\n    var heatmapFactory = {\n        create: function (config) {\n            return new Heatmap(config);\n        },\n        register: function (pluginKey, plugin) {\n            HeatmapConfig.plugins[pluginKey] = plugin;\n        },\n    };\n    return heatmapFactory;\n}\nvar h337 = create();\n/**\n * @namespace BMap的所有library类均放在BMapLib命名空间下\n */\nvar BMapLib = (window.BMapLib = BMapLib || {});\n(function () {\n    /**\n     * @exports HeatmapOverlay as BMapLib.HeatmapOverlay\n     */\n    var HeatmapOverlay = \n    /**\n     * 热力图的覆盖物\n     * @class 热力图的覆盖物\n     * 实例化该类后，使用map.addOverlay即可以添加热力图\n     *\n     * @constructor\n     * @param {Json Object} opts 可选的输入参数，非必填项。可输入选项包括：<br />\n     * {\"<b>radius</b>\" : {String} 热力图的半径,\n     * <br />\"<b>visible</b>\" : {Number} 热力图是否显示,\n     * <br />\"<b>gradient</b>\" : {JSON} 热力图的渐变区间,\n     * <br />\"<b>opacity</b>\" : {Number} 热力的透明度,\n     *\n     * @example <b>参考示例：</b><br />\n     * var   map = new BMap.Map(\"container\");<br />map.centerAndZoom(new BMap.Point(116.404, 39.915), 15);<br />var   heatmapOverlay = new BMapLib.HeatmapOverlay({\"radius\":10, \"visible\":true, \"opacity\":70});<br />heatmapOverlay.setDataSet(data);//data是热力图的详细数据\n     */\n    (BMapLib.HeatmapOverlay = function (opts) {\n        this.conf = opts;\n        this.conf.visible = opts.visible === undefined ? true : opts.visible;\n        this.heatmap = null;\n        this.latlngs = [];\n        this.bounds = null;\n    });\n    HeatmapOverlay.prototype = new BMap.Overlay();\n    HeatmapOverlay.prototype.initialize = function (map) {\n        this._map = map;\n        var el = document.createElement('div');\n        el.style.position = 'absolute';\n        el.style.top = 0;\n        el.style.left = 0;\n        el.style.border = 0;\n        el.style.width = this._map.getSize().width + 'px';\n        el.style.height = this._map.getSize().height + 'px';\n        this.conf.element = el;\n        if (!isSupportCanvas()) {\n            // 判断是否支持Canvas.\n            return el;\n        }\n        map.getPanes().mapPane.appendChild(el);\n        this.conf.valueField = this.conf.valueField || 'count';\n        // if (typeof module !== 'undefined' && module.exports) {\n        //   this.heatmap = module.exports.create(this.conf);\n        // } else {\n        this.heatmap = h337.create(this.conf);\n        // }\n        var that = this;\n        map.addEventListener('resize', function (e) {\n            var size = e.size;\n            el.style.width = size.width + 'px';\n            el.style.height = size.height + 'px';\n            that.heatmap._renderer.setDimensions(size.width, size.height);\n            that.draw();\n        });\n        this._div = el;\n        return el;\n    };\n    HeatmapOverlay.prototype.draw = function () {\n        if (!isSupportCanvas()) {\n            //判断是否支持Canvas.\n            return;\n        }\n        var currentBounds = this._map.getBounds();\n        if (currentBounds.equals(this.bounds)) {\n            return;\n        }\n        this.bounds = currentBounds;\n        var ne = this._map.pointToOverlayPixel(currentBounds.getNorthEast()), sw = this._map.pointToOverlayPixel(currentBounds.getSouthWest()), topY = ne.y, leftX = sw.x, h = sw.y - ne.y, w = ne.x - sw.x;\n        this.conf.element.style.left = leftX + 'px';\n        this.conf.element.style.top = topY + 'px';\n        this.conf.element.style.width = w + 'px';\n        this.conf.element.style.height = h + 'px';\n        //this.heatmap.store.get(\"heatmap\").resize();\n        if (this.latlngs.length > 0) {\n            this.heatmap.removeData();\n            var len = this.latlngs.length;\n            var d = {\n                max: this.heatmap._store.getData().max,\n                data: [],\n            };\n            while (len--) {\n                var latlng = this.latlngs[len].latlng;\n                if (!currentBounds.containsPoint(latlng)) {\n                    continue;\n                }\n                var divPixel = this._map.pointToOverlayPixel(latlng), leftX = this._map.pointToOverlayPixel(currentBounds.getSouthWest()).x, topY = this._map.pointToOverlayPixel(currentBounds.getNorthEast()).y, screenPixel = new BMap.Pixel(divPixel.x - leftX, divPixel.y - topY);\n                var roundedPoint = this.pixelTransform(screenPixel);\n                d.data.push({\n                    x: roundedPoint.x,\n                    y: roundedPoint.y,\n                    count: this.latlngs[len].c,\n                });\n            }\n            if (this.conf.radiusChangeByZoom) {\n                this.heatmap._store._cfgRadius = this.conf.radiusChangeByZoom(this._map.getZoom());\n            }\n            this.heatmap.setData(d);\n        }\n    };\n    //内部使用的坐标转化\n    HeatmapOverlay.prototype.pixelTransform = function (p) {\n        var w = this.heatmap.width, h = this.heatmap.height;\n        while (p.x < 0) {\n            p.x += w;\n        }\n        while (p.x > w) {\n            p.x -= w;\n        }\n        while (p.y < 0) {\n            p.y += h;\n        }\n        while (p.y > h) {\n            p.y -= h;\n        }\n        p.x = p.x >> 0;\n        p.y = p.y >> 0;\n        return p;\n    };\n    /**\n     * 设置热力图展现的详细数据, 实现之后,即可以立刻展现\n     * @param {Json Object } data\n     * {\"<b>max</b>\" : {Number} 权重的最大值,\n     * <br />\"<b>data</b>\" : {Array} 坐标详细数据,格式如下 <br/>\n     * {\"lng\":116.421969,\"lat\":39.913527,\"count\":3}, 其中<br/>\n     * lng lat分别为经纬度, count权重值\n     */\n    HeatmapOverlay.prototype.setDataSet = function (data) {\n        this.data = data;\n        if (!isSupportCanvas()) {\n            //判断是否支持Canvas.\n            return;\n        }\n        var currentBounds = this._map.getBounds();\n        var mapdata = {\n            max: data.max,\n            data: [],\n        };\n        var d = data.data, dlen = d.length;\n        this.latlngs = [];\n        this.heatmap.removeData();\n        if (this.conf.radiusChangeByZoom) {\n            this.heatmap._store._cfgRadius = this.conf.radiusChangeByZoom(this._map.getZoom());\n        }\n        while (dlen--) {\n            var latlng = new BMap.Point(d[dlen].lng, d[dlen].lat);\n            this.latlngs.push({\n                latlng: latlng,\n                c: d[dlen].count,\n            });\n            if (!currentBounds.containsPoint(latlng)) {\n                continue;\n            }\n            var divPixel = this._map.pointToOverlayPixel(latlng), leftX = this._map.pointToOverlayPixel(currentBounds.getSouthWest()).x, topY = this._map.pointToOverlayPixel(currentBounds.getNorthEast()).y, screenPixel = new BMap.Pixel(divPixel.x - leftX, divPixel.y - topY);\n            var point = this.pixelTransform(screenPixel);\n            mapdata.data.push({\n                x: point.x,\n                y: point.y,\n                count: d[dlen].count,\n            });\n        }\n        this.heatmap.setData(mapdata);\n    };\n    /**\n     * 添加热力图的详细坐标点\n     * @param {Number} lng 经度坐标\n     * @param {Number} lat 纬度坐标\n     * @param {Number} count 权重\n     */\n    HeatmapOverlay.prototype.addDataPoint = function (lng, lat, count) {\n        if (!isSupportCanvas()) {\n            return;\n        }\n        if (this.data && this.data.data) {\n            this.data.data.push({\n                lng: lng,\n                lat: lat,\n                count: count,\n            });\n        }\n        var latlng = new BMap.Point(lng, lat), point = this.pixelTransform(this._map.pointToOverlayPixel(latlng));\n        this.heatmap.store.addDataPoint(point.x, point.y, count);\n        this.latlngs.push({\n            latlng: latlng,\n            c: count,\n        });\n    };\n    /**\n     * 更改热力图的展现或者关闭\n     */\n    HeatmapOverlay.prototype.toggle = function () {\n        if (!isSupportCanvas()) {\n            //判断是否支持Canvas.\n            return;\n        }\n        if (this.conf.visible === true) {\n            this.conf.visible = false;\n        }\n        else {\n            this.conf.visible = true;\n        }\n        if (this.conf.visible) {\n            this.conf.element.style.display = 'block';\n        }\n        else {\n            this.conf.element.style.display = 'none';\n        }\n    };\n    /**\n     * 设置热力图展现的配置\n     * @param {Json Object} options 可选的输入参数，非必填项。可输入选项包括：<br />\n     * {\"<b>radius</b>\" : {String} 热力图的半径,\n     * <br />\"<b>visible</b>\" : {Number} 热力图是否显示,\n     * <br />\"<b>gradient</b>\" : {JSON} 热力图的渐变区间,\n     * <br />\"<b>opacity</b>\" : {Number} 热力的透明度,}\n     */\n    HeatmapOverlay.prototype.setOptions = function (options) {\n        if (!isSupportCanvas()) {\n            // 判断是否支持Canvas.\n            return;\n        }\n        for (var key in options) {\n            if (key == 'radius') {\n                this.heatmap._store._cfgRadius = options[key];\n            }\n            if (key == 'opacity') {\n                options[key] = options[key] / 100;\n            }\n        }\n        this.heatmap.configure(options);\n        if (this.data) {\n            this.setDataSet(this.data); // 重新渲染\n        }\n    };\n    function isSupportCanvas() {\n        var elem = document.createElement('canvas');\n        return !!(elem.getContext && elem.getContext('2d'));\n    }\n})();\n"],"names":["create","defaultRadius","HeatmapConfig","defaultRenderer","defaultGradient","0.45","0.55","0.65","0.95","1","defaultMaxOpacity","defaultMinOpacity","defaultBlur","defaultXField","defaultYField","defaultValueField","plugins","Store","prototype","_organiseData","dataPoint","forceRender","x","this","_xField","y","_yField","radi","_radi","store","_data","max","_max","min","_min","value","_valueField","radius","_cfgRadius","setDataMax","_unOrganizeData","unorganizedData","data","push","_onExtremaChange","_coordinator","emit","addData","arguments","length","dataArr","dataLen","call","organisedEntry","setData","dataPoints","pointsLen","i","_getInternalData","removeData","setDataMin","setCoordinator","coordinator","getData","config","_getColorPalette","key","gradientConfig","gradient","paletteCanvas","document","createElement","paletteCtx","getContext","width","height","createLinearGradient","addColorStop","fillStyle","fillRect","getImageData","Canvas2dRenderer","renderPartial","_drawAlpha","_colorize","renderAll","_clear","renderData","xValues","Object","keys","xValuesLen","xValue","yValues","yValuesLen","yValue","_updateGradient","_palette","updateConfig","_setStyles","setDimensions","_width","_height","canvas","shadowCanvas","shadowCtx","clearRect","ctx","_blur","blur","backgroundColor","style","_opacity","opacity","_maxOpacity","maxOpacity","_minOpacity","minOpacity","_useGradientOpacity","useGradientOpacity","blurFactor","tplCanvas","tplCtx","tpl","point","Math","rectX","rectY","_templates","beginPath","arc","PI","fill","createRadialGradient","globalAlpha","drawImage","_renderBoundaries","maxWidth","maxHeight","img","imgData","len","palette","alpha","offset","finalAlpha","putImageData","getValueAt","abs","getDataURL","toDataURL","container","element","computed","getComputedStyle","className","replace","cssText","position","appendChild","rendererFn","Coordinator","_connect","Renderer","Util","merged","argsLen","obj","Heatmap","on","evtName","callback","scope","cStore","renderer","_renderer","_store","_config","onExtremaChange","apply","configure","repaint","pluginToLoad","Error","plugin","register","pluginKey","h337","BMapLib","window","HeatmapOverlay","opts","conf","visible","undefined","heatmap","latlngs","bounds","isSupportCanvas","elem","BMap","Overlay","initialize","map","_map","that","el","top","left","border","getSize","getPanes","mapPane","valueField","addEventListener","e","size","draw","_div","currentBounds","getBounds","equals","ne","pointToOverlayPixel","getNorthEast","sw","getSouthWest","topY","leftX","h","w","d","latlng","containsPoint","divPixel","screenPixel","Pixel","roundedPoint","pixelTransform","count","c","radiusChangeByZoom","getZoom","p","setDataSet","mapdata","dlen","Point","lng","lat","addDataPoint","toggle","display","setOptions","options"],"mappings":"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"}